import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.d7865772.js";const D=JSON.parse('{"title":"常见算法套路","description":"","frontmatter":{"title":"常见算法套路","comment":true,"tags":["go"],"categories":["面试"],"sticky":1},"headers":[],"relativePath":"interviews/algorithm/常见算法套路.md","filePath":"interviews/algorithm/常见算法套路.md","lastUpdated":1685437102000}'),p={name:"interviews/algorithm/常见算法套路.md"},o=l(`<h1 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h1><h2 id="双指针" tabindex="-1">双指针 <a class="header-anchor" href="#双指针" aria-label="Permalink to &quot;双指针&quot;">​</a></h2><p>用到双指针的几道链表题：</p><p>1、合并两个有序链表</p><p>2、链表的分解</p><p>3、合并 <code>k</code> 个有序链表（先把node存到pq里，每次取最小节点）</p><p>4、寻找单链表的倒数第 <code>k</code> 个节点</p><p>5、寻找单链表的中点</p><p>6、判断单链表是否包含环并找出环起点</p><p>7、判断两个单链表是否相交并找出交点</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mergeTwoLists</span><span style="color:#E1E4E8;">(l1 </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ListNode, l2 </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ListNode) </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ListNode {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 虚拟头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    dummy </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">ListNode{</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">    p </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> dummy</span></span>
<span class="line"><span style="color:#E1E4E8;">    p1 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> l1</span></span>
<span class="line"><span style="color:#E1E4E8;">    p2 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> l2</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> p1 </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> p2 </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 比较 p1 和 p2 两个指针</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将值较小的的节点接到 p 指针</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> p1.Val </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> p2.Val {</span></span>
<span class="line"><span style="color:#E1E4E8;">            p.Next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p2</span></span>
<span class="line"><span style="color:#E1E4E8;">            p2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p2.Next</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            p.Next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p1</span></span>
<span class="line"><span style="color:#E1E4E8;">            p1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p1.Next</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// p 指针不断前进</span></span>
<span class="line"><span style="color:#E1E4E8;">        p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.Next</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> p1 </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        p.Next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p1</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> p2 </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        p.Next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p2</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> dummy.Next</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mergeTwoLists</span><span style="color:#24292E;">(l1 </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ListNode, l2 </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ListNode) </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ListNode {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 虚拟头结点</span></span>
<span class="line"><span style="color:#24292E;">    dummy </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">ListNode{</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">    p </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> dummy</span></span>
<span class="line"><span style="color:#24292E;">    p1 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> l1</span></span>
<span class="line"><span style="color:#24292E;">    p2 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> l2</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> p1 </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> p2 </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 比较 p1 和 p2 两个指针</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将值较小的的节点接到 p 指针</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> p1.Val </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> p2.Val {</span></span>
<span class="line"><span style="color:#24292E;">            p.Next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p2</span></span>
<span class="line"><span style="color:#24292E;">            p2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p2.Next</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            p.Next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p1</span></span>
<span class="line"><span style="color:#24292E;">            p1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p1.Next</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// p 指针不断前进</span></span>
<span class="line"><span style="color:#24292E;">        p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.Next</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> p1 </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        p.Next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p1</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> p2 </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        p.Next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p2</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> dummy.Next</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>链表题常用的虚拟头节点技巧，dummy节点</strong>可以避免一些空指针的判断，降低代码复杂度。</p><div class="tip custom-block"><p class="custom-block-title">什么时候用dummy</p><p>当需要创建一条新的链表时，可以用dummy节点简化边界处理。</p></div><h1 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h1><h2 id="快慢指针" tabindex="-1">快慢指针 <a class="header-anchor" href="#快慢指针" aria-label="Permalink to &quot;快慢指针&quot;">​</a></h2><p>看一个例子，数组原地去重</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">removeDuplicates</span><span style="color:#E1E4E8;">(nums []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(nums) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    slow,fast </span><span style="color:#F97583;">:=</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> fast</span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> nums[fast] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> nums[slow] {</span></span>
<span class="line"><span style="color:#E1E4E8;">            slow</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">             </span><span style="color:#6A737D;">// 维护 nums[0..slow] 无重复</span></span>
<span class="line"><span style="color:#E1E4E8;">            nums[slow] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[fast]</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        fast</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 数组长度为索引 + 1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> slow </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">removeDuplicates</span><span style="color:#24292E;">(nums []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(nums) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    slow,fast </span><span style="color:#D73A49;">:=</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> fast</span><span style="color:#D73A49;">&lt;</span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(nums) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> nums[fast] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> nums[slow] {</span></span>
<span class="line"><span style="color:#24292E;">            slow</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">             </span><span style="color:#6A737D;">// 维护 nums[0..slow] 无重复</span></span>
<span class="line"><span style="color:#24292E;">            nums[slow] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[fast]</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        fast</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 数组长度为索引 + 1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> slow </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>滑动窗口框架：</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-DH3B4" id="tab-P6oN7bu" checked="checked"><label for="tab-P6oN7bu">go</label><input type="radio" name="group-DH3B4" id="tab-ZXbaQRP"><label for="tab-ZXbaQRP">python</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 滑动窗口算法框架</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">slidingWindow</span><span style="color:#E1E4E8;">(s </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">, t </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化need 和 window</span></span>
<span class="line"><span style="color:#E1E4E8;">    need </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">map</span><span style="color:#E1E4E8;">[</span><span style="color:#F97583;">rune</span><span style="color:#E1E4E8;">]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    window </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">map</span><span style="color:#E1E4E8;">[</span><span style="color:#F97583;">rune</span><span style="color:#E1E4E8;">]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> _, c </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">range</span><span style="color:#E1E4E8;"> t {</span></span>
<span class="line"><span style="color:#E1E4E8;">        need[c]</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    left, right </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    valid </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        c </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">rune</span><span style="color:#E1E4E8;">(s[right])</span></span>
<span class="line"><span style="color:#E1E4E8;">        right</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 进行窗口内数据的更新</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> window needs shrink {</span></span>
<span class="line"><span style="color:#E1E4E8;">            d </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">rune</span><span style="color:#E1E4E8;">(s[left])</span></span>
<span class="line"><span style="color:#E1E4E8;">            left</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 进行窗口内数据的一系列更新</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 滑动窗口算法框架</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">slidingWindow</span><span style="color:#24292E;">(s </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">, t </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化need 和 window</span></span>
<span class="line"><span style="color:#24292E;">    need </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">map</span><span style="color:#24292E;">[</span><span style="color:#D73A49;">rune</span><span style="color:#24292E;">]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    window </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">map</span><span style="color:#24292E;">[</span><span style="color:#D73A49;">rune</span><span style="color:#24292E;">]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> _, c </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">range</span><span style="color:#24292E;"> t {</span></span>
<span class="line"><span style="color:#24292E;">        need[c]</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    left, right </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    valid </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s) {</span></span>
<span class="line"><span style="color:#24292E;">        c </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">rune</span><span style="color:#24292E;">(s[right])</span></span>
<span class="line"><span style="color:#24292E;">        right</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 进行窗口内数据的更新</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> window needs shrink {</span></span>
<span class="line"><span style="color:#24292E;">            d </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">rune</span><span style="color:#24292E;">(s[left])</span></span>
<span class="line"><span style="color:#24292E;">            left</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 进行窗口内数据的一系列更新</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># 滑动窗口算法框架</span></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">slidingWindow</span><span style="color:#E1E4E8;">(s: </span><span style="color:#79B8FF;">str</span><span style="color:#E1E4E8;">, t: </span><span style="color:#79B8FF;">str</span><span style="color:#E1E4E8;">):</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> collections </span><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> defaultdict</span></span>
<span class="line"><span style="color:#E1E4E8;">    need </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> defaultdict(</span><span style="color:#79B8FF;">int</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    window </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> defaultdict(</span><span style="color:#79B8FF;">int</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> t:</span></span>
<span class="line"><span style="color:#E1E4E8;">        need[c] </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    left, right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    valid </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s):</span></span>
<span class="line"><span style="color:#E1E4E8;">        c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s[right]</span></span>
<span class="line"><span style="color:#E1E4E8;">        right </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;"># 进行窗口内数据的一系列更新</span></span>
<span class="line"><span style="color:#E1E4E8;">        window[c] </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> window needs shrink:</span></span>
<span class="line"><span style="color:#E1E4E8;">            d </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s[left]</span></span>
<span class="line"><span style="color:#E1E4E8;">            left </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;"># 进行窗口内数据的一系列更新</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># 滑动窗口算法框架</span></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">slidingWindow</span><span style="color:#24292E;">(s: </span><span style="color:#005CC5;">str</span><span style="color:#24292E;">, t: </span><span style="color:#005CC5;">str</span><span style="color:#24292E;">):</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> collections </span><span style="color:#D73A49;">import</span><span style="color:#24292E;"> defaultdict</span></span>
<span class="line"><span style="color:#24292E;">    need </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> defaultdict(</span><span style="color:#005CC5;">int</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    window </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> defaultdict(</span><span style="color:#005CC5;">int</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> t:</span></span>
<span class="line"><span style="color:#24292E;">        need[c] </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    left, right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    valid </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s):</span></span>
<span class="line"><span style="color:#24292E;">        c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s[right]</span></span>
<span class="line"><span style="color:#24292E;">        right </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;"># 进行窗口内数据的一系列更新</span></span>
<span class="line"><span style="color:#24292E;">        window[c] </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> window needs shrink:</span></span>
<span class="line"><span style="color:#24292E;">            d </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s[left]</span></span>
<span class="line"><span style="color:#24292E;">            left </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;"># 进行窗口内数据的一系列更新</span></span></code></pre></div></div></div><h2 id="左右指针" tabindex="-1">左右指针 <a class="header-anchor" href="#左右指针" aria-label="Permalink to &quot;左右指针&quot;">​</a></h2><h3 id="二分查找" tabindex="-1">二分查找 <a class="header-anchor" href="#二分查找" aria-label="Permalink to &quot;二分查找&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">binarySearch</span><span style="color:#E1E4E8;">(nums []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, target </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#E1E4E8;">    left, right </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(nums)</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right {</span></span>
<span class="line"><span style="color:#E1E4E8;">        mid </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> right) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> nums[mid] </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> target {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> mid</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> nums[mid] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> target {</span></span>
<span class="line"><span style="color:#E1E4E8;">            left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> nums[mid] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> target {</span></span>
<span class="line"><span style="color:#E1E4E8;">            right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">binarySearch</span><span style="color:#24292E;">(nums []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, target </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#24292E;">    left, right </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(nums)</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> right {</span></span>
<span class="line"><span style="color:#24292E;">        mid </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> right) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> nums[mid] </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> target {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> mid</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> nums[mid] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> target {</span></span>
<span class="line"><span style="color:#24292E;">            left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mid </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> nums[mid] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> target {</span></span>
<span class="line"><span style="color:#24292E;">            right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mid </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="两数之和" tabindex="-1">两数之和 <a class="header-anchor" href="#两数之和" aria-label="Permalink to &quot;两数之和&quot;">​</a></h3><p><strong>数组有序就可以考虑左右指针</strong>， 类似二分法。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#E1E4E8;">    left, right </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(nums) </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right {</span></span>
<span class="line"><span style="color:#E1E4E8;">        sum </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> nums[left] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> nums[right]</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> sum </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> target {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 题目要求的索引是从 1 开始的</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">{left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, right </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> sum </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> target {</span></span>
<span class="line"><span style="color:#E1E4E8;">            left</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 让 sum 大一点</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> sum </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> target {</span></span>
<span class="line"><span style="color:#E1E4E8;">            right</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 让 sum 小一点</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">{</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#24292E;">    left, right </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(nums) </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> right {</span></span>
<span class="line"><span style="color:#24292E;">        sum </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> nums[left] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> nums[right]</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> sum </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> target {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 题目要求的索引是从 1 开始的</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">{left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, right </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> sum </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> target {</span></span>
<span class="line"><span style="color:#24292E;">            left</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 让 sum 大一点</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> sum </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> target {</span></span>
<span class="line"><span style="color:#24292E;">            right</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 让 sum 小一点</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">{</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="反转数组" tabindex="-1">反转数组 <a class="header-anchor" href="#反转数组" aria-label="Permalink to &quot;反转数组&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reverseString</span><span style="color:#E1E4E8;">(s []</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#E1E4E8;">    left, right </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s)</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 交换 s[left] 和 s[right]</span></span>
<span class="line"><span style="color:#E1E4E8;">        temp </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> s[left]</span></span>
<span class="line"><span style="color:#E1E4E8;">        s[left] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s[right]</span></span>
<span class="line"><span style="color:#E1E4E8;">        s[right] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> temp</span></span>
<span class="line"><span style="color:#E1E4E8;">        left</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        right</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reverseString</span><span style="color:#24292E;">(s []</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#24292E;">    left, right </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s)</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> right {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 交换 s[left] 和 s[right]</span></span>
<span class="line"><span style="color:#24292E;">        temp </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> s[left]</span></span>
<span class="line"><span style="color:#24292E;">        s[left] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s[right]</span></span>
<span class="line"><span style="color:#24292E;">        s[right] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> temp</span></span>
<span class="line"><span style="color:#24292E;">        left</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">        right</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="回文串判断" tabindex="-1">回文串判断 <a class="header-anchor" href="#回文串判断" aria-label="Permalink to &quot;回文串判断&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isPalindrome</span><span style="color:#E1E4E8;">(s </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#E1E4E8;">    left </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    right </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s) </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> s[left] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> s[right] {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        left</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">        right</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isPalindrome</span><span style="color:#24292E;">(s </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">bool</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 一左一右两个指针相向而行</span></span>
<span class="line"><span style="color:#24292E;">    left </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    right </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s) </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> right {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> s[left] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> s[right] {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        left</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">        right</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>最长回文串</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">longestPalindrome</span><span style="color:#E1E4E8;">(s </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 以 s[i] 为中心的最长回文子串</span></span>
<span class="line"><span style="color:#E1E4E8;">        s1 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">palindrome</span><span style="color:#E1E4E8;">(s, i, i)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span>
<span class="line"><span style="color:#E1E4E8;">        s2 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">palindrome</span><span style="color:#E1E4E8;">(s, i, i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// res = longest(res, s1, s2)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(res) </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s1) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s1</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(res) </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s2</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">palindrome</span><span style="color:#E1E4E8;">(s </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">, l </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, r </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 防止索引越界</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> l </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> r </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> s[l] </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> s[r] {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 向两边展开</span></span>
<span class="line"><span style="color:#E1E4E8;">        l</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">        r</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> s[l</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> : r]</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">longestPalindrome</span><span style="color:#24292E;">(s </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 以 s[i] 为中心的最长回文子串</span></span>
<span class="line"><span style="color:#24292E;">        s1 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">palindrome</span><span style="color:#24292E;">(s, i, i)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span>
<span class="line"><span style="color:#24292E;">        s2 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">palindrome</span><span style="color:#24292E;">(s, i, i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// res = longest(res, s1, s2)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(res) </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s1) {</span></span>
<span class="line"><span style="color:#24292E;">            res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s1</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(res) </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s2) {</span></span>
<span class="line"><span style="color:#24292E;">            res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s2</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">palindrome</span><span style="color:#24292E;">(s </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">, l </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, r </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 防止索引越界</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> l </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> r </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> s[l] </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> s[r] {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 向两边展开</span></span>
<span class="line"><span style="color:#24292E;">        l</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">        r</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> s[l</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> : r]</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h1 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h1><p>二叉树解题的思维模式分两类：</p><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p><p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p><p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p><p><strong>如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了</strong>。</p><p>快排：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(nums []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, lo, hi </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/****** 前序遍历位置 ******/</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过交换元素构建分界点 p</span></span>
<span class="line"><span style="color:#E1E4E8;">    p </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">partition</span><span style="color:#E1E4E8;">(nums, lo, hi)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/************************/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">sort</span><span style="color:#E1E4E8;">(nums, lo, p </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">sort</span><span style="color:#E1E4E8;">(nums, p </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, hi)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(nums []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, lo, hi </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/****** 前序遍历位置 ******/</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过交换元素构建分界点 p</span></span>
<span class="line"><span style="color:#24292E;">    p </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">partition</span><span style="color:#24292E;">(nums, lo, hi)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/************************/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">sort</span><span style="color:#24292E;">(nums, lo, p </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">sort</span><span style="color:#24292E;">(nums, p </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, hi)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>归并：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 定义：排序 nums[lo..hi]</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(nums []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, lo </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, hi </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    mid </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> (lo </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> hi) </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 排序 nums[lo..mid]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">sort</span><span style="color:#E1E4E8;">(nums, lo, mid)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 排序 nums[mid+1..hi]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">sort</span><span style="color:#E1E4E8;">(nums, mid </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, hi)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/****** 后序位置 ******/</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">merge</span><span style="color:#E1E4E8;">(nums, lo, mid, hi)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/*********************/</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 定义：排序 nums[lo..hi]</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(nums []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, lo </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, hi </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    mid </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> (lo </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> hi) </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 排序 nums[lo..mid]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">sort</span><span style="color:#24292E;">(nums, lo, mid)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 排序 nums[mid+1..hi]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">sort</span><span style="color:#24292E;">(nums, mid </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, hi)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/****** 后序位置 ******/</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">merge</span><span style="color:#24292E;">(nums, lo, mid, hi)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/*********************/</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="遍历框架" tabindex="-1">遍历框架 <a class="header-anchor" href="#遍历框架" aria-label="Permalink to &quot;遍历框架&quot;">​</a></h2><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Left)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 中序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Right)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Left)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 中序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Right)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 迭代遍历数组</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(arr []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i</span><span style="color:#F97583;">:=</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(arr); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 递归遍历数组</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(arr []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, i </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(arr) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(arr, i</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 迭代遍历单链表</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(head </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ListNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> p</span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;">head; p</span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;">; p</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">p.Next {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 递归遍历单链表</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(head </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ListNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> head </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(head.Next)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 迭代遍历数组</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(arr []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> i</span><span style="color:#D73A49;">:=</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">&lt;</span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(arr); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 递归遍历数组</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(arr []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, i </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(arr) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(arr, i</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 迭代遍历单链表</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(head </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ListNode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> p</span><span style="color:#D73A49;">:=</span><span style="color:#24292E;">head; p</span><span style="color:#D73A49;">!=</span><span style="color:#005CC5;">nil</span><span style="color:#24292E;">; p</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">p.Next {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 递归遍历单链表</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(head </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ListNode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> head </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(head.Next)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>单链表和数组的遍历可以是迭代的，也可以是递归的，<strong>二叉树这种结构无非就是二叉链表</strong>，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。</p><p>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</p><p>如果让你<strong>倒序打印</strong>一条单链表上所有节点的值，你怎么搞？</p><p>实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(head </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ListNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> head </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(head.Next)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(head.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(head </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ListNode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> head </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(head.Next)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#24292E;">    fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(head.Val)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>二叉树中用遍历思路解题时函数签名一般是 <code>void traverse(...)</code>，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。</p></blockquote><h3 id="两种方案解决二叉树的最大深度" tabindex="-1">两种方案解决二叉树的最大深度 <a class="header-anchor" href="#两种方案解决二叉树的最大深度" aria-label="Permalink to &quot;两种方案解决二叉树的最大深度&quot;">​</a></h3><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-aeL5y" id="tab-W8Qq4Wf" checked="checked"><label for="tab-W8Qq4Wf">go</label><input type="radio" name="group-aeL5y" id="tab-_Nxkup1"><label for="tab-_Nxkup1">go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 记录最大深度</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> res </span><span style="color:#F97583;">int</span></span>
<span class="line"><span style="color:#6A737D;">// 记录遍历到的节点的深度</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> depth </span><span style="color:#F97583;">int</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 主函数</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">maxDepth</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root)</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二叉树遍历框架</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">	depth</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root.Left </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> root.Right </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// 到达叶子节点，更新最大深度</span></span>
<span class="line"><span style="color:#E1E4E8;">		res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">max</span><span style="color:#E1E4E8;">(res, depth)</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Left)</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Right)</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">	depth</span><span style="color:#F97583;">--</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(a, b </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> b {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 记录最大深度</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> res </span><span style="color:#D73A49;">int</span></span>
<span class="line"><span style="color:#6A737D;">// 记录遍历到的节点的深度</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> depth </span><span style="color:#D73A49;">int</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 主函数</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">maxDepth</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root)</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二叉树遍历框架</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#24292E;">	depth</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root.Left </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> root.Right </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">// 到达叶子节点，更新最大深度</span></span>
<span class="line"><span style="color:#24292E;">		res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">max</span><span style="color:#24292E;">(res, depth)</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Left)</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Right)</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#24292E;">	depth</span><span style="color:#D73A49;">--</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(a, b </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> b {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">maxDepth</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用定义，计算左右子树的最大深度</span></span>
<span class="line"><span style="color:#E1E4E8;">    leftMax </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">maxDepth</span><span style="color:#E1E4E8;">(root.Left)</span></span>
<span class="line"><span style="color:#E1E4E8;">    rightMax </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">maxDepth</span><span style="color:#E1E4E8;">(root.Right)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 然后再加上根节点自己</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">max</span><span style="color:#E1E4E8;">(leftMax, rightMax) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(a </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, b </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> b {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">maxDepth</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用定义，计算左右子树的最大深度</span></span>
<span class="line"><span style="color:#24292E;">    leftMax </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">maxDepth</span><span style="color:#24292E;">(root.Left)</span></span>
<span class="line"><span style="color:#24292E;">    rightMax </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">maxDepth</span><span style="color:#24292E;">(root.Right)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 然后再加上根节点自己</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">max</span><span style="color:#24292E;">(leftMax, rightMax) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(a </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, b </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> b {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></div></div><h2 id="二叉树的前中后序遍历" tabindex="-1">二叉树的前中后序遍历 <a class="header-anchor" href="#二叉树的前中后序遍历" aria-label="Permalink to &quot;二叉树的前中后序遍历&quot;">​</a></h2><ul><li><p>前序遍历</p><p><strong>一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果</strong></p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-wkuAz" id="tab-VsfFXnR" checked="checked"><label for="tab-VsfFXnR">go</label><input type="radio" name="group-wkuAz" id="tab-_xBPcCH"><label for="tab-_xBPcCH">go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preorderTraversal</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">res)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二叉树遍历函数</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode, res </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">[]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res, root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Left, res)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Right, res)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">preorderTraversal</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">res)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二叉树遍历函数</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode, res </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">[]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res, root.Val)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Left, res)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Right, res)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preorderTraversal</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前序遍历的结果，root.val 在第一个</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用函数定义，后面接着左子树的前序遍历结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, </span><span style="color:#79B8FF;">preorderTraversal</span><span style="color:#E1E4E8;">(root.Left)</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用函数定义，最后接着右子树的前序遍历结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, </span><span style="color:#79B8FF;">preorderTraversal</span><span style="color:#E1E4E8;">(root.Right)</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">preorderTraversal</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前序遍历的结果，root.val 在第一个</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, root.Val)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用函数定义，后面接着左子树的前序遍历结果</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, </span><span style="color:#005CC5;">preorderTraversal</span><span style="color:#24292E;">(root.Left)</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用函数定义，最后接着右子树的前序遍历结果</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, </span><span style="color:#005CC5;">preorderTraversal</span><span style="color:#24292E;">(root.Right)</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></div></div></li><li><p>中序遍历</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-KvNRI" id="tab-uo0sWlY" checked="checked"><label for="tab-uo0sWlY">go</label><input type="radio" name="group-KvNRI" id="tab-T5Z39Qj"><label for="tab-T5Z39Qj">go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">inorderTraversal</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    result </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">result)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode, result </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">[]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Left, result)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 中序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">result, root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Right, result)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">inorderTraversal</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    result </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">result)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode, result </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">[]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Left, result)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 中序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">result, root.Val)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Right, result)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">inorderTraversal</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用函数定义，后面接着左子树的前序遍历结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, </span><span style="color:#79B8FF;">inorderTraversal</span><span style="color:#E1E4E8;">(root.Left)</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用函数定义，最后接着右子树的前序遍历结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, </span><span style="color:#79B8FF;">inorderTraversal</span><span style="color:#E1E4E8;">(root.Right)</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">inorderTraversal</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用函数定义，后面接着左子树的前序遍历结果</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, </span><span style="color:#005CC5;">inorderTraversal</span><span style="color:#24292E;">(root.Left)</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, root.Val)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用函数定义，最后接着右子树的前序遍历结果</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, </span><span style="color:#005CC5;">inorderTraversal</span><span style="color:#24292E;">(root.Right)</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></div></div></li><li><p>后序遍历</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-CaqJK" id="tab-gq6yZwF" checked="checked"><label for="tab-gq6yZwF">go</label><input type="radio" name="group-CaqJK" id="tab-AUzuMvk"><label for="tab-AUzuMvk">go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postorderTraversal</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    result </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">result)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode, result </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">[]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Left, result)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Right, result)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">result, root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postorderTraversal</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    result </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">result)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode, result </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">[]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Left, result)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Right, result)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 后序位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">result, root.Val)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postorderTraversal</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用函数定义，后面接着左子树的前序遍历结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, </span><span style="color:#79B8FF;">postorderTraversal</span><span style="color:#E1E4E8;">(root.Left)</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用函数定义，最后接着右子树的前序遍历结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, </span><span style="color:#79B8FF;">postorderTraversal</span><span style="color:#E1E4E8;">(root.Right)</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postorderTraversal</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用函数定义，后面接着左子树的前序遍历结果</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, </span><span style="color:#005CC5;">postorderTraversal</span><span style="color:#24292E;">(root.Left)</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用函数定义，最后接着右子树的前序遍历结果</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, </span><span style="color:#005CC5;">postorderTraversal</span><span style="color:#24292E;">(root.Right)</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, root.Val)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></div></div></li><li><p>层序遍历</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-dPz_q" id="tab-ufKf5_O" checked="checked"><label for="tab-ufKf5_O">go</label><input type="radio" name="group-dPz_q" id="tab-QJSpvhL"><label for="tab-QJSpvhL">go</label></div><div class="blocks"><div class="language-go vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">levelOrder</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) [][]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> [][]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">{}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    q </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> []</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode{root}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(q) </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        sz </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(q)</span></span>
<span class="line"><span style="color:#E1E4E8;">        level </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">{}</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> sz; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            cur </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> q[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">            q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> q[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">:]</span></span>
<span class="line"><span style="color:#E1E4E8;">            level </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(level, cur.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> cur.Left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(q, cur.Left)</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> cur.Right </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(q, cur.Right)</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(res, level)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">levelOrder</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) [][]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> [][]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">{}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    q </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> []</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode{root}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(q) </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        sz </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(q)</span></span>
<span class="line"><span style="color:#24292E;">        level </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">{}</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> sz; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            cur </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> q[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">            q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> q[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">:]</span></span>
<span class="line"><span style="color:#24292E;">            level </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(level, cur.Val)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> cur.Left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(q, cur.Left)</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> cur.Right </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(q, cur.Right)</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(res, level)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">levelOrder</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode) [][]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">([][]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">res)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">TreeNode, depth </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, res </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">[][]</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res) </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> depth {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res, []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">{})</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res)[depth] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">append</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">res)[depth], root.Val)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Left, depth</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, res)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">traverse</span><span style="color:#E1E4E8;">(root.Right, depth</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, res)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">levelOrder</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode) [][]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">([][]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">res)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(root </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">TreeNode, depth </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">, res </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">[][]</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res) </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> depth {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res, []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">{})</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    (</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res)[depth] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">append</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">res)[depth], root.Val)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Left, depth</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, res)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">traverse</span><span style="color:#24292E;">(root.Right, depth</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, res)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></div></div></li></ul><div class="tip custom-block"><p class="custom-block-title">总结</p><p>遇到一道二叉树的题目时的通用思考过程是：</p><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p><p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p><p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p><p><strong>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据</strong>。</p><p><strong>一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/" target="_blank" rel="noreferrer">东哥带你刷二叉树</a></li></ul>`,57),e=[o];function c(t,r,E,y,i,F){return n(),a("div",null,e)}const A=s(p,[["render",c]]);export{D as __pageData,A as default};
