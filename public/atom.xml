<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lpdswing&#39;blogs</title>
  
  <subtitle>技术分享领跑者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-18T10:37:48.023Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lpdswing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/04/18/test/"/>
    <id>http://yoursite.com/2020/04/18/test/</id>
    <published>2020-04-18T10:37:48.000Z</published>
    <updated>2020-04-18T10:37:48.023Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>coding持续集成自动部署hexo博客</title>
    <link href="http://yoursite.com/2020/04/18/coding%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/04/18/coding持续集成自动部署hexo博客/</id>
    <published>2020-04-18T08:48:58.000Z</published>
    <updated>2020-04-18T08:49:38.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="coding平台设置"><a href="#coding平台设置" class="headerlink" title="coding平台设置"></a>coding平台设置</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;coding平台设置&quot;&gt;&lt;a href=&quot;#coding平台设置&quot; class=&quot;headerlink&quot; title=&quot;coding平台设置&quot;&gt;&lt;/a&gt;coding平台设置&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>django进阶</title>
    <link href="http://yoursite.com/2018/05/03/django%E8%BF%9B%E9%98%B6-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/05/03/django进阶-中间件/</id>
    <published>2018-05-03T11:19:39.000Z</published>
    <updated>2020-04-18T05:05:20.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="django进阶"><a href="#django进阶" class="headerlink" title="django进阶"></a>django进阶</h1><ol><li><p><strong>HTTP Objects</strong></p><p> <strong>HttpRequest</strong> </p><p>​    <strong>自身属性</strong> </p><p>​        <code>request.path -&gt; /foo/bar/</code></p><p>​        <code>request.method</code></p><p>​        <code>request.GET</code></p><p>​        <code>request.POST</code></p><p>​        <code>request.COOKIES</code></p><p>​        <code>request.FILES -&gt; {name1: file1, name2: file2, ...}</code></p><p>​        <code>request.META[&#39;REMOTE_ADDR&#39;]</code></p><p>​        <code>request.META[&#39;HTTP_USER_AGENT&#39;]</code></p><p>​    <strong>中间件添加的属性</strong> </p><p>​        request.session </p><p>​        request.user </p><p>​    <strong>方法</strong> </p><p>​        request.get_full_path() -&gt; /foo/bar/?a=123 </p><p>​        request.get_signed_cookie(key) </p><p><strong>HttpResponse</strong> </p><p>​    <strong>属性</strong> </p><p>​        response.status_code </p><p>​        response.content </p><p>​    <strong>方法</strong> </p><p>​        response.set_cookie(key, value, max_age=None) </p><p><strong>JsonHttpResponse</strong> </p><pre><code>`response = JsonHttpResponse({&#39;a&#39;: 12, &#39;b&#39;: &#39;xyz&#39;})`</code></pre></li><li><p>django 中间件</p><p>最简单的中间件:aop面向切片编程</p><p>自己写一个获取接口数据的中间件</p><pre><code class="python">class Result(MiddlewareMixin):    def process_view(self,request,view_func,*args,**kwargs):        #执行view函数.获取rc        try:            print(args,kwargs)            view_result =view_func(request)            rc = 0        except Exception as e:            view_result = None            rc = str(e)        #获取 msg        uid = request.GET.get(&#39;uid&#39;)        msg = cache.get(f&#39;msg-{uid}&#39;) #python3才有f拼接        data ={            &#39;result&#39;: view_result,            &#39;rc&#39;: rc,            &#39;msg&#39;:msg        }        return JsonResponse(data)</code></pre><p>最简单的装饰器—装饰器形式</p></li></ol><pre><code class="python">def simple_middeware(get_response):    #do_something  for __init__()    def middleware(request):        # do something before_views()        t=time.time()        response = get_response(request) #view 函数在这里执行        print(time.time()-t)        # do something after_views()        return response    return middleware</code></pre><p>装饰器的运行方式</p><pre><code class="python">def timer(func):    def wrap(*args,**kwargs):        t= time.time()        res= func(*args,**kwargs)        print(time.time()-t)        return res    return wrap@timerdef foo(n)    time.sleep(n)#被装饰后,这时候 foo.__name__ 已经变成了wrap而不是foo了# 相当于timer(foo)(0.5)-&gt;wrap(0.5)</code></pre><p>中间件类</p><pre><code class="python">class MyMiddleware:    def __init__(self,view_func):        self.view_func = view_func  #动态添加属性    def __call__(self,request):        response = self.view_func(request)        return response    def process_view(self,request,view_func,view_args,view_kwargs):        pass-----------------def foo():    pass# 执行foo()实际上执行的是foo.__call__()------------------class A:    passa = A()#a()没有call方法,但是A是有的A.__call__()-&gt;A的实例-------------------class A:    def __call__(self,n):        print(n)a = A()a(1)1#现在a()是可以调用的,可以用callable(a)查看</code></pre><h3 id="django1-10之前的中间件"><a href="#django1-10之前的中间件" class="headerlink" title="django1.10之前的中间件"></a>django1.10之前的中间件</h3><p>继承自MiddlewareMixin</p><pre><code class="python">from django.utils.deprecation import MiddlewareMixinclass MyMiddleware(MiddlewareMixin):     def process_request(self, request):        pass    def process_view(self, request, view_func, view_args, view_kwargs):        pass    def process_response(self, request, response):        return response</code></pre><p>执行顺序 process_request, process_view 从上往下执行 </p><p>process_response 从下往上执行 </p><p><a href="https://docs.djangoproject.com/en/2.0/ref/middleware/#middleware-ordering" target="_blank" rel="noopener">内置中间件的排序</a></p><ol start="6"><li><p>Cache</p><p> 默认缓存: from django.core.cache import cache </p><p>BACKEND: DatabaseCache / MemcachedCache / LocMemCache </p><p>LOCATION: IP:Port 绑定, 只有一个时配制成字符串链接, 有多台时配制为列表 </p><p>使用 Redis 做缓存 </p><pre><code class="Python">CACHES = {     &quot;default&quot;: {     &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,     &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;,     &quot;OPTIONS&quot;: {         &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,         &quot;PICKLE_VERSION&quot;: ‑1,         }     } }</code></pre><p><strong>基本方法</strong> </p><p><code>cache.set(key, value, timeout=None)</code> </p><p><code>cache.get(key, default=None)</code> </p></li></ol><pre><code>   cache.delete(key)    cache.incr(&#39;num&#39;)    cache.decr(&#39;num&#39;)    cache.get_or_set(key, default, timeout=None) </code></pre><p>   <code>cache.set_many({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</code> </p><p>   <code>cache.get_many([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code> </p><p>   <strong>全站缓存中间件</strong>: <code>django.middleware.cache.UpdateCacheMiddleware</code></p><p>   ​    前置中间件 </p><pre><code>   缓存期限: `CACHE_MIDDLEWARE_SECONDS `</code></pre><p>   <strong>页面缓存装饰器</strong>: <code>from django.views.decorators.cache import cache_page</code></p><p>   <strong>属性缓存装饰器</strong>: <code>from django.utils.functional import cached_property</code></p><p>   <strong>pickle</strong> </p><p>   ​    dumps </p><p>   ​    loads</p><ol start="7"><li><p><strong>Cookie 和 Session</strong></p><p> <strong>Cookie:</strong> response.set_cookie(key, value, max_age=None) </p><p><strong>Session 配置</strong> </p><p>​    a. 开启 Session 中间件: django.contrib.sessions.middleware.SessionMiddleware </p><p>​    b. 配置缓存 </p><p>​    c. 配置 Session 引擎: SESSION_ENGINE = “django.contrib.sessions.backends.cache” </p><p><strong>可选项</strong> </p><p>​    SESSION_COOKIE_AGE 缓存时间, 默认 2 周 </p><p>​    SESSION_COOKIE_NAME Session 名, 默认 ‘sessionid’ </p><pre><code>SESSION_EXPIRE_AT_BROWSER_CLOSE 浏览器关闭页面时, Session 是否设为过期                                                     `SESSION_SAVE_EVERY_REQUEST 每次请求时, 是否强制保存一次 Session `</code></pre></li></ol><p>   <strong>用法</strong> </p><p>   request.session.session_key 查看 session_id </p><p>   request.session.modified session 是否发生过修改 </p><p>   request.session[‘uid’] = 1234 当 session 发生更改时会自动保存 </p><p>   request.session.get(‘uid’) 取值 </p><p>   request.session.save() 手动保存</p><hr><h3 id="手写一个login-require装饰器验证用户是否登录"><a href="#手写一个login-require装饰器验证用户是否登录" class="headerlink" title="手写一个login_require装饰器验证用户是否登录"></a>手写一个login_require装饰器验证用户是否登录</h3><pre><code class="python">def login_require(view_func):    def check_login(request):        if request.session.get(&#39;name&#39;):            return view_func(request)        else:            return redirect(&#39;/login/&#39;)    return check_login</code></pre><pre><code class="Python">#login的view函数def login(request):    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    if username==USER and password ==PASSWORD:        user = User(username = USER)        request.session[&#39;uid&#39;]=user.id        return render()    else:        return redirect(&#39;/login/&#39;)</code></pre><pre><code class="Python">#手写一个中间件验证用户已经登录,比如用户登录后才能编辑评论等(全局的)class Auth(MiddlewareMixin):    def process_request(self,request):        uid = request.session.get(&#39;uid&#39;)        if uid is not None:            user = User.objects.get(id = uid)            request.user = user   #动态添加一个user属性 setattr(request,&#39;user&#39;,user)        else:            if request.path not in [&#39;/user/login/&#39;,&#39;/user/register/&#39;]            return redirect(&#39;/login/&#39;)</code></pre><ol start="8"><li><p><strong>Logging</strong> </p><p><strong>日志级别</strong> </p><p>​    DEBUG </p><p>​    INFO </p><p>​    WARN </p><p>​    ERROR </p><p>​    FATAL </p><p><strong>使用</strong> </p><p>logger.debug(‘xxxxxxxx’) </p><p>logger.info(‘xxxxxxxx’) </p><p>logger.warning(‘xxxxxxxx’) </p><p>logger.error(‘xxxxxxxx’) </p><p>logger.fatal(‘xxxxxxxx’) </p><p><strong>查找、分析</strong> </p><p>tail </p><p>head </p><p>less </p><p>awk </p><p>grep </p><p><strong>配置</strong> </p><pre><code class="Python">LOGGING = {     &#39;version&#39;: 1,     &#39;disable_existing_loggers&#39;: True,     &#39;formatters&#39;: {         &#39;simple&#39;: { &#39;format&#39;: &#39;%(asctime)s %(module)s.%(funcName)s: %(message)s&#39;,         &#39;datefmt&#39;: &#39;%Y‑%m‑%d %H:%M:%S&#39;, },         &#39;verbose&#39;: {             &#39;format&#39;: &#39;%(asctime)s %(levelname)s [%(process)d‑%(threadName)s] &#39;                      &#39;%(module)s.%(funcName)s line %(lineno)d: %(message)s&#39;,             &#39;datefmt&#39;: &#39;%Y‑%m‑%d %H:%M:%S&#39;,             }             },     &#39;handlers&#39;: {         &#39;inf&#39;: {             &#39;class&#39;: &#39;logging.handlers.TimedRotatingFileHandler&#39;,             &#39;filename&#39;: &#39;/data/web/gnt.out&#39;,             &#39;when&#39;: &#39;W0&#39;, # 每周一切割日志             &#39;backupCount&#39;: 5,             &#39;formatter&#39;: &#39;simple&#39;,             &#39;level&#39;: &#39;DEBUG&#39; if DEBUG else &#39;INFO&#39;,             },             &#39;err&#39;: {                 &#39;class&#39;: &#39;logging.handlers.TimedRotatingFileHandler&#39;,                 &#39;filename&#39;: &#39;/data/web/gnt.err&#39;,                 &#39;when&#39;: &#39;D&#39;, # 每天切割日志 &#39;backupCount&#39;: 5,                 &#39;formatter&#39;: &#39;verbose&#39;,                 &#39;level&#39;: &#39;WARNING&#39;,                 }             },         &#39;loggers&#39;: {             &#39;inf&#39;: {                 &#39;handlers&#39;: [&#39;inf&#39;],                 &#39;level&#39;: &#39;DEBUG&#39;,                 &#39;propagate&#39;: True,                 },             &#39;err&#39;: {                 &#39;handlers&#39;: [&#39;err&#39;],                 &#39;level&#39;: &#39;DEBUG&#39;,                 &#39;propagate&#39;: True,                 }             }         }</code></pre><p>一个打印日志的装饰器</p><hr><pre><code class="python">def statistic(view_func):    def wrap(request.*args,**kwargs):        ip = request.META[&#39;REMOTE_ADDR&#39;]        aid = int(request.GET.get(&#39;aid&#39;,0))        logger.info(f&#39;{ip}  {aid}&#39;)        return view_func(request,*args,**kwargs)    return wrap</code></pre></li></ol><ol start="9"><li><p><strong>Django 的性能</strong></p><p> <strong>Django 自身优化</strong> </p><p>​    <code>充分之用缓存</code></p><p>​    <code>惰性求值和迭代器</code></p><p>​    <code>尽量使用 defer() 和 only() 查找</code></p><p>​    <code>尽量使用 count() 和 exists()</code></p><p>​    模板中<code>{</code>% block %<code>}</code>性能优于<code>{</code>% include %<code>}</code></p><p>​    <code>开启模板缓存</code></p><p>​    <code>不要使用外键！不要使用外键！不要使用外键！</code></p><p><strong>其他优化</strong> </p><p>​    <strong>I/O 密集型: 异步化</strong> </p><p>​        请求异步化 </p><p>​        数据操作异步化 </p><p>​        gevent, asyncio, aiopg, aiohttp, tornado </p><p>​    <strong>计算密集型</strong> </p><p>​        耗时操作用 Celery 等工具异步完成 </p><p>​    <strong>分库分表</strong> </p><p>​        取余、哈希 </p><p>​        范围 </p><p>​        一致性哈希 </p><p>​    <strong>索引优化</strong> </p><p>​    慢查询优化 (相关工具: DjangoDebugToolbar) </p><p>​    Gunicorn 开启多进程模式利用多核 </p><p>​    PyPy </p><p>​    Cython</p></li></ol><hr><h3 id="异步调用任务"><a href="#异步调用任务" class="headerlink" title="异步调用任务"></a>异步调用任务</h3><pre><code class="Python">from functools import update_wrapperdef async_call(func):    &#39;&#39;&#39;异步调用任务&#39;&#39;&#39;    func.trace_err =trace_err    func.trace_info = &#39;%s.%s&#39;%(trace_code(2),func.func_name)    def wrapper(*args,**kwargs)        global main_thread        try:            main_thread.MMQ.submit(func,*args,**kwargs)        except AttributeError:            return func(*args,**kwargs)    return update_wrapper(wrapper,func)</code></pre><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><pre><code class="python">#生成器  使用next调用def foo():    for i in range(10):        yield i x = foo()next(x)#惰性求值,占内存小  ----python2中的xrange类似</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code class="python">class Iter:    def __iter__(self):        return self    def __next__(self):        return 1o =Iter()class Iter:    def __init__(self):        self.v = 0    def __iter__(self):        return self    def __next__(self):        self.v +=1        return self.v   #迭代的规则写在next方法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;django进阶&quot;&gt;&lt;a href=&quot;#django进阶&quot; class=&quot;headerlink&quot; title=&quot;django进阶&quot;&gt;&lt;/a&gt;django进阶&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;HTTP Objects&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>django进阶-zx版</title>
    <link href="http://yoursite.com/2018/05/03/Django%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/05/03/Django进阶/</id>
    <published>2018-05-03T10:16:44.000Z</published>
    <updated>2020-04-18T05:05:20.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-进阶"><a href="#Django-进阶" class="headerlink" title="Django 进阶"></a>Django 进阶</h1><blockquote><p>由于hexo编码问题,所有的%都加上了”%”</p></blockquote><ol><li><p><a href="https://docs.djangoproject.com/en/2.0/ref/request-response/" target="_blank" rel="noopener">HTTP Objects</a></p><ul><li>HttpRequest<ul><li>自身属性<ul><li>request.path -&gt; <code>/foo/bar/</code></li><li>request.method</li><li>request.GET</li><li>request.POST</li><li>request.COOKIES</li><li>request.FILES -&gt; <code>{name1: file1, name2: file2, ...}</code></li><li>request.META[‘REMOTE_ADDR’]</li><li>request.META[‘HTTP_USER_AGENT’]</li></ul></li><li>中间件添加的属性<ul><li>request.session</li><li>request.user</li></ul></li><li>方法<ul><li>request.get_full_path() -&gt; <code>/foo/bar/?a=123</code></li><li>request.get_signed_cookie(key)</li></ul></li></ul></li><li>HttpResponse<ul><li>属性<ul><li>response.status_code</li><li>response.content</li></ul></li><li>方法<ul><li>response.set_cookie(key, value, max_age=None)</li></ul></li></ul></li><li>JsonHttpResponse<ul><li><code>response = JsonHttpResponse({&#39;a&#39;: 12, &#39;b&#39;: &#39;xyz&#39;})</code></li></ul></li></ul></li><li><p>Django 中间件</p><ul><li><p>最简单的中间件</p><pre><code>  def simple_middleware(get_response):      # do_something_for_init()      def middleware(request):          # do_something_before_views()          response = get_response(request)  # views 函数在这里执行          # do_something_after_views()          return response      return middleware</code></pre></li><li><p>中间件类</p><pre><code>  class MyMiddleware:      def __init__(self, get_response):          self.get_response = get_response      def __call__(self, request):          response = self.get_response(request)          return response      def process_view(self, request, view_func, view_args, view_kwargs):          pass</code></pre></li><li><p>Django-1.10 以前的中间件</p><pre><code>  from django.utils.deprecation import MiddlewareMixin  class MyMiddleware(MiddlewareMixin):      def process_request(self, request):          pass      def process_view(self, request, view_func, view_args, view_kwargs):          pass      def process_response(self, request, response):          return response</code></pre></li><li><p>执行顺序</p><ul><li>process_request, process_view 从上往下执行</li><li>process_response 从下往上执行</li></ul></li><li><a href="https://docs.djangoproject.com/en/2.0/ref/middleware/#middleware-ordering" target="_blank" rel="noopener">内置中间件的排序</a></li></ul></li><li><p>Form 表单</p><ul><li>form 的 method 只能是 POST 或 GET</li><li>method=GET 时, 表单提交的参数会出现在 URL 里</li><li>属性和方法<ul><li>form.is_valid()</li><li>form.has_changed()</li><li>form.cleaned_data[‘fieldname’]</li></ul></li><li><p>Form 的定义和使用</p><pre><code>  from django.forms import Form  from django.forms import IntegerField, CharField, DateField, ChoiceField  class TestForm(Form):      TAGS = (          (&#39;py&#39;, &#39;python&#39;),          (&#39;ln&#39;, &#39;linux&#39;),          (&#39;dj&#39;, &#39;django&#39;),      )      fid = IntegerField()      name = CharField(max_length=10)      tag = ChoiceField(choices=TAGS)      date = DateField()  data = {&#39;fid&#39;: 123, &#39;name&#39;: &#39;1234567890&#39;, &#39;tag&#39;: &#39;dj&#39;, &#39;date&#39;: &#39;2017-12-17&#39;}  form = TestForm(data)  print(form.is_valid())  print(form.cleaned_data)  # cleaned_data 属性是 is_valid 函数执行时动态添加的</code></pre></li><li><p>ModelForm</p><pre><code>  class UserForm(ModelForm):      class Meta:          model = User          fields = [&#39;name&#39;, &#39;birth&#39;]</code></pre></li></ul></li><li><p>模板</p><ul><li><p>base.html 模板推荐布局</p><pre><code>  &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;      &lt;title&gt;{{title}}&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/css/style.css&quot;&gt;      {&quot;%&quot; block &quot;ext_css&quot; &quot;%&quot;}{&quot;%&quot; endblock &quot;%&quot;}  &lt;/head&gt;  &lt;body&gt;      &lt;!-- {&quot;%&quot; block &quot;navbar&quot; &quot;%&quot;}{&quot;%&quot; endblock &quot;%&quot;} --&gt;      {&quot;%&quot; block &quot;sidebar&quot; &quot;%&quot;}{&quot;%&quot; endblock &quot;%&quot;}      {&quot;%&quot; block &quot;content&quot; &quot;%&quot;}{&quot;%&quot; endblock &quot;%&quot;}      &lt;!-- {&quot;%&quot; block &quot;foot&quot; &quot;%&quot;}{&quot;%&quot; endblock &quot;%&quot;} --&gt;      {&quot;%&quot; block &quot;ext_js&quot; &quot;%&quot;}{&quot;%&quot; endblock &quot;%&quot;}  &lt;/body&gt;  &lt;/html&gt;</code></pre></li><li><p><a href="https://docs.djangoproject.com/en/2.0/ref/templates/builtins/#ref-templates-builtins-tags" target="_blank" rel="noopener">内建 Tags</a></p><ul><li><p><code>autoescape</code></p><pre><code>  {&quot;%&quot; autoescape off &quot;%&quot;}      {{ body }}  {&quot;%&quot; endautoescape &quot;%&quot;}</code></pre></li><li><p><code>csrf_token</code></p><pre><code>  &lt;form&gt;  {&quot;%&quot; csrf_token &quot;%&quot;}  &lt;/form&gt;</code></pre></li><li><p><code>for...endfor</code> 中的变量</p><ul><li><code>forloop.counter</code>     从 1 开始计数</li><li><code>forloop.counter0</code>    从 0 开始计数</li><li><code>forloop.revcounter</code>  逆序计数到 1</li><li><code>forloop.revcounter0</code> 逆序计数到 0</li><li><code>forloop.first</code>       是否是循环中的第一个</li><li><code>forloop.last</code>        是否是循环中的最后一个</li><li><code>forloop.parentloop</code>  用于引用上级循环中的变量, 如 <code></code></li></ul></li><li><p>empty 子句</p><pre><code>  {&quot;%&quot; for x in lst &quot;%&quot;}      &lt;div&gt;...&lt;/div&gt;  {&quot;%&quot; empty &quot;%&quot;}      &lt;div&gt;Sorry&lt;/div&gt;  {&quot;%&quot; endfor &quot;%&quot;}</code></pre></li><li><p>load: 加载自定义 Tag {<code>&quot;%&quot;</code>load foo.bar <code>&quot;%&quot;</code>}</p></li><li>url: 根据 url name 替换 {<code>&quot;%&quot;</code> url ‘your-url-name’ v1 v2 <code>&quot;%&quot;</code>}</li><li><p>static</p><pre><code>  {&quot;%&quot; load static &quot;%&quot;}  &lt;img src=&quot;{&quot;%&quot; static &quot;img/smile.jpg&quot; &quot;%&quot;}&quot;&gt;</code></pre><p>  或</p><pre><code>  {&quot;%&quot; load static &quot;%&quot;}  &lt;img src=&quot;{&quot;%&quot; get_static_prefix &quot;%&quot;}img/smile.jpg&quot;&gt;</code></pre></li></ul></li><li><p><a href="https://docs.djangoproject.com/en/2.0/ref/templates/builtins/#built-in-filter-reference" target="_blank" rel="noopener">内建的 filter</a></p><ul><li>safe 和 escape: <code></code></li></ul></li><li><p><a href="https://docs.djangoproject.com/en/2.0/topics/templates/#django.template.backends.jinja2.Jinja2" target="_blank" rel="noopener">使用 Jinja2 替换内置模板引擎</a></p></li></ul></li><li><p>ORM</p><ul><li>什么是 ORM</li><li>CURD (Create/Update/Retrieve/Delete)</li><li><a href="https://docs.djangoproject.com/en/2.0/ref/models/fields/" target="_blank" rel="noopener">Field</a></li><li>Field 选项<ul><li><code>null</code>    针对数据库, 允许数据库该字段为 Null</li><li><code>blank</code>   针对 Model 本身, 允许传入字段为空. blank 为 True 时, 对数据库来说, 该字段依然为必填项</li><li><code>default</code> 尽量使用 default, 少用 null 和 blank</li><li><code>choices</code></li><li><code>primary_key</code> 非必要时不要设置, 用默认 id, 保持条目自增、有序</li><li><code>unique</code></li><li><code>db_index</code>    (True | False)</li><li><code>max_length</code></li><li><code>auto_now</code>     每次 save 时，更新为当前时间</li><li><code>auto_now_add</code> 只记录创建时的时间, 保存时不更新</li></ul></li><li><a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/" target="_blank" rel="noopener">QuerySet</a><ul><li>方法<ul><li>创建: <code>create() / get_or_create() / update_or_create() / bulk_create()</code></li><li>条件过滤和排除: <code>filter() / exclude()</code></li><li>只加载需要的字段: <code>only() / defer()</code></li><li><code>order_by() / count() / exists()</code></li><li><code>latest() / earliest()</code></li><li><code>first() / last()</code></li></ul></li><li>查找条件<ul><li><code>filter(id__in=[123, 555, 231])</code></li><li><code>filter(id__range=[123, 456])</code></li><li><code>filter(name__contains=&#39;123&#39;)</code></li><li><code>filter(name__regex=&#39;^\w+\d+&#39;)</code></li><li><code>gt / gte / lt / lte</code></li></ul></li></ul></li><li>其他 ORM<ul><li>sqlalchemy</li><li>peewee</li></ul></li><li>主键和外键约束<ul><li>内部系统、传统企业级应用可以使用 (需要数据量可控，数据库服务器数量可控)</li><li>互联网行业不建议使用<ul><li>性能缺陷</li><li>不能用于分布式环境</li><li>不容易做到数据解耦</li></ul></li></ul></li></ul></li><li><p>Cache</p><ul><li>默认缓存: <code>from django.core.cache import cache</code></li><li>BACKEND: <code>DatabaseCache / MemcachedCache / LocMemCache</code></li><li>LOCATION: IP:Port 绑定, 只有一个时配制成字符串链接, 有多台时配制为列表</li><li><p>使用 Redis 做缓存</p><pre><code>  CACHES = {      &quot;default&quot;: {          &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;,          &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379/1&quot;,          &quot;OPTIONS&quot;: {              &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;,              &quot;PICKLE_VERSION&quot;: -1,          }      }  }</code></pre></li><li><p>基本方法</p><ul><li><code>cache.set(key, value, timeout=None)</code></li><li><code>cache.get(key, default=None)</code></li><li><code>cache.delete(key)</code></li><li><code>cache.incr(&#39;num&#39;)</code></li><li><code>cache.decr(&#39;num&#39;)</code></li><li><code>cache.get_or_set(key, default, timeout=None)</code></li><li><code>cache.set_many({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})</code></li><li><code>cache.get_many([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></li></ul></li><li>全站缓存中间件: <code>django.middleware.cache.UpdateCacheMiddleware</code><ul><li>前置中间件</li><li>缓存期限: CACHE_MIDDLEWARE_SECONDS</li></ul></li><li>页面缓存装饰器: <code>from django.views.decorators.cache import cache_page</code></li><li>属性缓存装饰器: <code>from django.utils.functional import cached_property</code></li><li>pickle<ul><li>dumps</li><li>loads</li></ul></li></ul></li><li><p>Cookie 和 Session</p><ul><li>Cookie: <code>response.set_cookie(key, value, max_age=None)</code></li><li>Session 配置<ol><li>开启 Session 中间件: <code>django.contrib.sessions.middleware.SessionMiddleware</code></li><li>配置缓存</li><li>配置 Session 引擎: <code>SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot;</code></li></ol></li><li>可选项<ul><li><code>SESSION_COOKIE_AGE</code>              缓存时间, 默认 2 周</li><li><code>SESSION_COOKIE_NAME</code>             Session 名, 默认 ‘sessionid’</li><li><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code> 浏览器关闭页面时, Session 是否设为过期</li><li><code>SESSION_SAVE_EVERY_REQUEST</code>      每次请求时, 是否强制保存一次 Session</li></ul></li><li>用法<ul><li><code>request.session.session_key</code>     查看 session_id</li><li><code>request.session.modified</code>        session 是否发生过修改</li><li><code>request.session[&#39;uid&#39;] = 1234</code>   当 session 发生更改时会自动保存</li><li><code>request.session.get(&#39;uid&#39;)</code>      取值</li><li><code>request.session.save()</code>          手动保存</li></ul></li></ul></li><li><p>Logging</p><ul><li>日志级别<ul><li>DEBUG</li><li>INFO</li><li>WARNING</li><li>ERROR</li><li>FATAL</li></ul></li><li>使用<ul><li>logger.debug(‘xxxxxxxx’)</li><li>logger.info(‘xxxxxxxx’)</li><li>logger.warning(‘xxxxxxxx’)</li><li>logger.error(‘xxxxxxxx’)</li><li>logger.fatal(‘xxxxxxxx’)</li></ul></li><li>查找、分析<ul><li>tail</li><li>head</li><li>less</li><li>awk</li><li>grep</li></ul></li><li><p><a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="noopener">配置</a></p><pre><code>  LOGGING = {      &#39;version&#39;: 1,      &#39;disable_existing_loggers&#39;: True,      &#39;formatters&#39;: {          &#39;simple&#39;: {              &#39;format&#39;: &#39;&quot;%&quot;(asctime)s &quot;%&quot;(module)s.&quot;%&quot;(funcName)s: &quot;%&quot;(message)s&#39;,              &#39;datefmt&#39;: &#39;&quot;%&quot;Y-&quot;%&quot;m-&quot;%&quot;d &quot;%&quot;H:&quot;%&quot;M:&quot;%&quot;S&#39;,          },          &#39;verbose&#39;: {              &#39;format&#39;: &#39;&quot;%&quot;(asctime)s &quot;%&quot;(levelname)s [&quot;%&quot;(process)d-&quot;%&quot;(threadName)s] &#39;                        &#39;&quot;%&quot;(module)s.&quot;%&quot;(funcName)s line &quot;%&quot;(lineno)d: &quot;%&quot;(message)s&#39;,              &#39;datefmt&#39;: &#39;&quot;%&quot;Y-&quot;%&quot;m-&quot;%&quot;d &quot;%&quot;H:&quot;%&quot;M:&quot;%&quot;S&#39;,          }      },      &#39;handlers&#39;: {          &#39;inf&#39;: {              &#39;class&#39;: &#39;logging.handlers.TimedRotatingFileHandler&#39;,              &#39;filename&#39;: &#39;/data/web/gnt.out&#39;,              &#39;when&#39;: &#39;W0&#39;,  # 每周一切割日志              &#39;backupCount&#39;: 5,              &#39;formatter&#39;: &#39;simple&#39;,              &#39;level&#39;: &#39;DEBUG&#39; if DEBUG else &#39;INFO&#39;,          },          &#39;err&#39;: {              &#39;class&#39;: &#39;logging.handlers.TimedRotatingFileHandler&#39;,              &#39;filename&#39;: &#39;/data/web/gnt.err&#39;,              &#39;when&#39;: &#39;D&#39;,  # 每天切割日志              &#39;backupCount&#39;: 5,              &#39;formatter&#39;: &#39;verbose&#39;,              &#39;level&#39;: &#39;WARNING&#39;,          }      },      &#39;loggers&#39;: {          &#39;inf&#39;: {              &#39;handlers&#39;: [&#39;inf&#39;],              &#39;level&#39;: &#39;DEBUG&#39;,              &#39;propagate&#39;: True,          },          &#39;err&#39;: {              &#39;handlers&#39;: [&#39;err&#39;],              &#39;level&#39;: &#39;DEBUG&#39;,              &#39;propagate&#39;: True,          }      }  }</code></pre></li></ul></li><li><p>Django 的性能</p><ul><li>Django 自身优化<ul><li>充分之用缓存</li><li>惰性求值和迭代器</li><li>尽量使用 <code>defer()</code> 和 <code>only()</code> 查找</li><li>尽量使用 <code>count()</code> 和 <code>exists()</code></li><li>模板中 <code>{&quot;%&quot; block &quot;%&quot;}</code> 性能优于 <code>{&quot;%&quot; include &quot;%&quot;}</code></li><li><a href="https://docs.djangoproject.com/en/2.0/ref/templates/api/#django.template.loaders.cached.Loader" target="_blank" rel="noopener">开启模板缓存</a></li><li><strong>不要使用外键！不要使用外键！不要使用外键！</strong></li></ul></li><li>其他优化<ul><li>I/O 密集型: 异步化<ul><li>请求异步化</li><li>数据操作异步化</li><li>gevent, asyncio, aiopg, aiohttp, tornado</li></ul></li><li>计算密集型<ul><li>耗时操作用 <a href="http://docs.jinkan.org/docs/celery/" target="_blank" rel="noopener">Celery</a> 等工具异步完成</li></ul></li><li>分库分表<ul><li>取余、哈希</li><li>范围</li><li>一致性哈希</li></ul></li><li>索引优化</li><li>慢查询优化 (<a href="https://django-debug-toolbar.readthedocs.io" target="_blank" rel="noopener">相关工具: DjangoDebugToolbar</a>)</li><li>Gunicorn 开启多进程模式利用多核</li><li>PyPy</li><li>Cython</li></ul></li></ul></li><li><p>Python / Django 环境加载</p><ul><li>sys.argv</li><li>sys.path</li><li>os.environ</li></ul></li><li><p>Git</p><ul><li>常用操作<ul><li>git init</li><li>git clone</li><li>git add</li><li>git commit -m ‘xxxxxxxx’</li><li>git push</li><li>git pull</li><li>git fetch</li><li>git log</li><li>git checkout</li><li>git branch</li><li>git merge</li></ul></li><li>代码管理<ul><li>code review<ul><li>发现代码逻辑问题</li><li>代码风格及规范化问题</li><li>算法问题</li><li>错误的使用方式</li><li>能够学习其他人的优秀代码</li></ul></li><li>分支: master / dev / feature</li></ul></li></ul></li><li><p>Blog</p><ol><li>基础功能<ol><li>看文章</li><li>写文章</li><li>查看文章列表</li><li>根据正文搜索文章</li><li>可以评论</li></ol></li><li><p>扩展功能</p><ol start="0"><li>实现分页功能: 首页文章列表每页显示 5 篇文章</li><li>实现一个基于 redis 的文章缓存</li><li>给首页增加一个模块, 显示最受欢迎的 10 篇文章 (点击率最高的)</li><li>创建用户模块<ul><li>实现注册、登录功能</li><li>添加用户个人信息展示</li><li>开发头像上传功能</li></ul></li><li>写一个装饰器, 在 blog.log 文件中输出阅读文章的用户 IP, 及所读文章的 ID</li><li><p>基于日志的简单统计</p><ul><li><p>计算出阅读次数最多的文章: <code>awk &#39;{print $6}&#39; blog6.log | sort | uniq -c | sort -r</code></p></li><li><p>计算出每个访客读了多少篇文章: <code>awk &#39;{print $5}&#39; blog6.log | sort | uniq -c | sort -r</code></p></li></ul></li><li><p>写一个中间件, 限制用户的访问频率最大为每秒 2 次，超过 2 次时，等待至合理时间再返回</p></li><li>给文章增加 Tag 功能:<ul><li>每篇文章可以添加多个 Tag</li><li>每个 Tag 分类下有多篇文章</li><li>点击每个 Tag 直接跳转到此 tag 的文章列表</li><li>不要使用外键</li></ul></li><li>实现权限管理功能<ul><li>未登录用户只能查看文章</li><li>普通注册用户，可以发表评论</li><li>管理员，可以发表和删除文章、评论</li></ul></li><li><a href="http://docs.gunicorn.org/en/latest/install.html" target="_blank" rel="noopener">使用 Gunicorn 驱动 Django, 对比性能差异</a><ul><li>文件描述符</li><li>单台服务器最大连接数</li><li>TCP 连接上限</li></ul></li><li><p>Nginx</p><ul><li><p>负载均衡: 轮询, 权重, IP 哈希</p><pre><code>                 User Requests               |    |    |    |               V    V    V    V               www.example.com                   DNS 轮训                 /         \                V           V            Nginx            Nginx         113.5.3.10        110.2.9.11         ---&gt; Nginx 绑定公网 IP         /        |        |       \        V         V        V        V  AppServer  AppServer  AppServer  AppServer  ---&gt; Gunicorn + Django  10.0.0.1   10.0.0.2   10.0.0.3   10.0.0.3   ---&gt; AppServer 绑定内网 IP  weight:2   weight:5   weight:10  weight:20  ---&gt; 权重</code></pre></li><li><p>为什么用 Nginx, 不直接用 gunicorn</p></li><li>代理网站、图片</li><li>Nginx 和 Apache 的区别</li></ul></li><li><p>压力测试</p><ul><li>ab</li><li>webbench</li></ul></li><li>其他: uWSGI, tornado</li></ol></li></ol></li><li><p>项目</p><ul><li>代码组织</li><li>常用组件<ul><li>nginx</li><li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis</a></li><li>MySQL</li><li>软件安装<ul><li><code>apt-get</code></li><li><code>yum</code></li><li><code>make</code> / <code>make install</code></li></ul></li></ul></li><li>DB 集群<ul><li>主从备份</li><li>一主两从</li><li>双主互备</li></ul></li></ul></li><li><p>静态文件存储</p><ul><li>线上系统 Django 会关掉自身的静态文件处理</li><li>用 Nginx 代理静态文件</li><li>CDN (内容分发网络)<ul><li>基于缓存技术为静态资源 (主要是多媒体资源) 提供访问加速的服务</li><li>在不同地区部署镜像服务器节点</li><li>定期与源站做内容同步</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django-进阶&quot;&gt;&lt;a href=&quot;#Django-进阶&quot; class=&quot;headerlink&quot; title=&quot;Django 进阶&quot;&gt;&lt;/a&gt;Django 进阶&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;由于hexo编码问题,所有的%都加上了”%”&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>web基础-zx版</title>
    <link href="http://yoursite.com/2018/05/03/Web%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/05/03/Web基础/</id>
    <published>2018-05-03T10:16:44.000Z</published>
    <updated>2020-04-18T05:05:20.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h1><ol><li><p>HyperText Transfer Protocol</p><ol><li>HTTP 1.0 (1996) / 1.1 (1997) / 2.0 (2015)</li><li>构建在 TCP 应用层之上的协议</li><li>应用领域</li><li>认识 URL (统一资源定位符)<ul><li><code>http://example.com:80/foo/bar/readme?x=0&amp;y=abc#part1</code></li><li>组成<ul><li>scheme: http</li><li>hostname: example.com</li><li>port: 80</li><li>path: /foo/bar/readme</li><li>query: ?x=0&amp;y=abc</li><li>fragment: #part1</li></ul></li></ul></li></ol></li><li><p>Python 系常见 Web 框架</p><ul><li>Django<ul><li>全能型框架, 大而全, 插件丰富, 文档丰富, 社区活跃, 适合快速开发, 内部耦合比较紧</li></ul></li><li>Flask<ul><li>微型框架, 适合新手学习, 极其灵活, 便于二次开发和扩展, 生态环境好, 插件丰富</li></ul></li><li>Tornado<ul><li>异步处理, 事件驱动 (epoll), 性能优异</li></ul></li><li>web.py<ul><li>代码优秀, 适合学习源码</li></ul></li><li>bottle<ul><li>单文件框架</li></ul></li><li>其他<ul><li>Falcon</li><li>web2py</li><li>Quixote</li><li>Sanic</li></ul></li></ul></li><li><p>点击一个链接后, 都发生了什么</p><ol><li>DNS解析<ul><li>example.com -&gt; 93.184.216.34</li><li><code>dig example.com</code></li><li><code>nslookup example.com</code></li><li><code>/etc/hosts</code></li></ul></li><li>建立TCP<ol><li>SYN</li><li>ACK + SYN</li><li>ACK</li></ol></li><li>生成 Request 报文</li><li>Client 发送 Request 报文</li><li>Server 接收报文</li><li>通过 WSGI 解析报文, 获得 Request 对象</li><li>Django、Flask 等应用程序进行逻辑处理<ol start="0"><li>生成 Request 对象</li><li>process_request (Middleware)</li><li>URL match</li><li>process_views (Middleware)</li><li>Views  –&gt;  process_exception</li><li>Redner Template</li><li>Response</li><li>process_response (Middleware)</li></ol></li><li>从 Response 对象生成报文</li><li>Server 返回报文给 Client</li><li>关闭连接</li><li>解析、渲染 HTML 页面</li></ol></li><li><p>最简单的 Server</p><ul><li>HTTP Server<ul><li>创建、关闭连接</li><li>发送、接收数据</li></ul></li><li>WSGI: 沟通 HTTPServer 和 Web 应用程序 之间的接口</li><li>Web Application<ul><li>网络程序的功能和逻辑</li><li>解析用户请求, 生成 HTML 页面</li></ul></li></ul></li><li><p>常见 Header 字段</p><ul><li>Accept            text/plain</li><li>Accept-Charset    utf-8</li><li>Accept-Encoding   gzip (Content-Encoding)</li><li>Accept-Language   zh-CN en-US</li><li>Cache-Control     true,max-age</li><li>Connection        keep-alive</li><li>Content-Length    请求体/响应体的长度</li><li>Content-Type      用于指定响应的HTTP内容类型. 如果未指定 默认为 text/html</li><li>User-Agent        浏览器标识</li></ul></li><li><p>HTTP 状态码</p><ul><li>200 <strong>OK</strong>                      成功</li><li>301 <strong>Moved Permanently</strong>       重定向 (永久迁移)</li><li>302 <strong>Moved Temporarily</strong>       重定向 (临时迁移)</li><li>303 <strong>See Other</strong>               重定向 (非 GET 请求的重定向)</li><li>400 <strong>Bad Request</strong>             客户端请求错误</li><li>403 <strong>Forbidden</strong>               拒绝访问</li><li>404 <strong>Not Found</strong>               找不到页面</li><li>500 <strong>Internal Server Error</strong>   服务器内部错误</li><li>502 <strong>Bad Gateway</strong>             网关错误</li><li>503 <strong>Service Unavailable</strong>     服务器维护或者过载</li><li>504 <strong>Gateway Timeout</strong>         请求超时</li></ul></li><li><p>GET 和 POST</p><ul><li>表象<ul><li>GET 在浏览器可以回退, 而 POST 则会再次提交请求</li><li>GET 的 URL 可以被 Bookmark, 而 POST 不可以.</li><li>GET 请求会被浏览器主动缓存, 而 POST 不会, 除非手动设置.</li><li>GET 请求参数会被完整保留在浏览器历史记录里, 而 POST 中的参数不会被保留.</li><li>GET 请求的数据只能进行 URL 编码, 而 POST 支持多种编码方式.</li><li>GET 请求在 URL 中传送的参数是有长度限制的 (URL 的最大长度是 2048 个字符), 而 POST 没有.</li><li>对参数的数据类型, GET 只接受 ASCII 字符, 而 POST 没有限制.</li><li>GET 比 POST 更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息.</li><li>GET 参数通过 URL 传递, POST 放在 Request body 中.</li></ul></li><li>深层<ul><li>GET 产生一个TCP数据包；POST产生两个TCP数据包.</li><li>GET: 浏览器会把 http 的 header和data一并发送出去, 服务器响应200（返回数据）；</li><li>POST: 浏览器先发送 header, 服务器响应 100 continue, 浏览器再发送data, 服务器响应200 ok（返回数据）.</li></ul></li></ul></li><li><p>cookie 和 session</p><ul><li>无状态协议的无奈之举<ul><li>通信如同一次无法看到脸的握手, 如何识别用户</li></ul></li><li>异同<ol><li>session 在服务器端, cookie 在客户端（浏览器）</li><li>session 默认被存在在服务器的一个文件里（不是内存）</li><li>session 的运行依赖 session id, 而 session id 是存在 cookie 中的, 也就是说, 如果浏览器禁用了 cookie , 同时 session 也会失效（但是可以通过其它方式实现, 比如在 url 中传递 session_id）</li><li>session 可以放在 文件、数据库、或内存中都可以.</li><li>用户验证这种场合一般会用 session</li></ol></li><li>产生过程<ol><li>客户端请求</li><li>服务器产生 session_id, 并传回浏览器</li><li>浏览器将 session_id 写入 cookie</li><li>后续请求会写入 Header</li></ol></li><li>使用</li></ul></li><li><p>RESTful</p><ul><li>一种网络软件架构风格, 而非标准</li><li>用 URL 定位一个网络资源</li><li>用 HTTP 描述对资源的操作</li><li>四个动词<ul><li>GET: 用来获取资源</li><li>POST: 用来新建资源</li><li>PUT: 用来更新资源</li><li>DELETE: 用来删除资源</li></ul></li><li>误区<ul><li>URL 中使用动词</li><li>URL 中出现版本号, 版本号放在 Header</li></ul></li></ul></li><li><p>HTTPS</p><ul><li>优点<ul><li>防窃听: 建立一个信息安全通道，来保证数据传输的安全</li><li>防篡改: 防止内容被第三方修改</li><li>放冒充: 确认网站的真实性</li></ul></li><li>缺点<ul><li>加密、解密消耗 CPU</li><li>握手过程繁琐</li></ul></li><li>SSL / TLS (安全套接字层)</li><li><p>加密算法</p><ul><li><p>对称加密: TEA, AES, 3DES</p><pre><code>  text: abcdefg          |  ^          v  |  key:    1234          |  ^          v  |  new:  hasjdkfhasdf</code></pre></li><li><p>非对称加密: RSA, ED25519</p><pre><code>  text:   abcdefghijklmn            |       ^            v       |  pub_key: 123      |  pri_key:  |   1234567890123456789546789            |       ^            v       |  new: ajsgdpfqibwfmbsdlkfjbq;ejkwbf;qkbfd</code></pre></li></ul></li><li><p>Let’s Encrypt: <a href="https://letsencrypt.org/" target="_blank" rel="noopener">https://letsencrypt.org/</a></p></li><li>传输过程 <img src="/image/https.png" alt="HTTPS"></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web-基础&quot;&gt;&lt;a href=&quot;#Web-基础&quot; class=&quot;headerlink&quot; title=&quot;Web 基础&quot;&gt;&lt;/a&gt;Web 基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HyperText Transfer Protocol&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python进阶</title>
    <link href="http://yoursite.com/2018/05/03/Python%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/05/03/Python进阶/</id>
    <published>2018-05-03T10:16:36.000Z</published>
    <updated>2020-04-18T05:05:20.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-进阶"><a href="#Python-进阶" class="headerlink" title="Python 进阶"></a>Python 进阶</h1><ol><li><p>PEP8 编码规范, 以及开发中的一些惯例和建议</p><ul><li>代码编排:<ul><li>缩进 4 个空格, 禁止空格与 Tab 混用</li><li>行长 80: 防止单行逻辑过于复杂</li></ul></li><li>适当添加空行<ul><li>函数间: 顶级函数间空 2 行, 类的方法之间空 1 行</li><li>函数内: 同一函数内的逻辑块之间, 空 1 行</li><li>文件结尾: 留一个空行</li></ul></li><li>import<ul><li>顺序<ol><li>标准库</li><li>第三方库</li><li>自定义库</li></ol></li><li>单行不要 import 多个库</li><li>模块内用不到的不要去 import</li></ul></li><li>空格</li><li>注释<ul><li>行注释</li><li>块注释</li><li>引入外来算法或者配置时须在注释中添加源连接, 标明出处</li><li>函数和类尽可能添加 <code>docstring</code></li></ul></li><li>命名<ul><li>包名、模块名、函数名、方法名全部使用小写, 单词间用下划线连接</li><li>类名、异常名使用 CapWords 的方式, 异常名结尾加 <code>Error</code> 或 <code>Wraning</code> 后缀</li><li>全局变量尽量使用大写, 一组同类型的全局变量要加上统一前缀, 单词用下划线连接</li></ul></li><li>字符串拼接尽量使用 <code>join</code> 方式: 速度快, 内存消耗小</li><li>语意明确、直白<ul><li><code>not xx in yy</code> vs <code>xx not in yy</code></li><li><code>not a is b</code> vs <code>a is not b</code></li></ul></li><li>程序构建<ul><li>一个函数只做一件事情, 并把这件事做好</li><li>大的功能用小函数之间灵活组合来完成</li><li>避免编写庞大的程序, “大”意味着体积庞大, 逻辑复杂甚至混乱</li></ul></li><li>函数名必须有动词, 最好是 do_something 的句式, 或者 somebody_do_something 句式</li><li>自定义的变量名、函数名不要与标准库中的名字冲突</li><li>pip install pep8</li><li><p>练习: 规范化这段代码</p><pre><code>  from django.conf import settings  import sys, os  mod=0xffffffff  def foo ( a , b = 123 ) :      c = { &#39;x&#39; : 111 , &#39;y&#39; : 222 }  # 定义一个字典      d = [ 1, 3 , 5 ]      return a , b , c  def bar(x):      if x%2 ==0: return true</code></pre></li></ul></li><li><p><code>*</code> 和 <code>**</code> 的用法</p><ul><li><p>函数定义</p><pre><code>  def foo(*args, **kwargs):      pass</code></pre></li><li><p>参数传递</p><pre><code>  def foo(x, y, z, a, b):      print(x)      print(y)      print(z)      print(a)      print(b)  lst = [1, 2, 3]  dic = {&#39;a&#39;: 22, &#39;b&#39;: 77}  foo(*lst, **dic)</code></pre></li><li><p>强制命名参数</p><pre><code>  def foo(a, *, b, c=123):      pass</code></pre></li><li><p>解包语法: <code>a, b, *ignored, c = [1, 2, 3, 4, 5, 6, 7]</code></p></li></ul></li><li><p>Python 的赋值和引用</p><ul><li><code>==, is</code>: <code>==</code> 判断的是值, <code>is</code> 判断的是内存地址 (即对象的id)</li><li>小整数对象: [-5, 256]</li><li><p><code>copy, deepcopy</code> 的区别</p><ul><li><code>copy</code>: 只拷贝表层元素</li><li><code>deepcopy</code>: 在内存中重新创建所有子元素</li><li><img src="/image/Copy.png" alt="copy and deepcopy"></li></ul></li><li><p>练习1: 说出执行结果</p><pre><code>  def extendList(val, lst=[]):      lst.append(val)      return lst  list1 = extendList(10)  list2 = extendList(123, [])  list3 = extendList(&#39;a&#39;)</code></pre></li><li><p>练习2: 说出下面执行结果</p><pre><code>  from copy import copy, deepcopy  from pickle import dumps, loads  a = [1, 2, 3]  b = [a] * 3  c = copy(b)  d = deepcopy(b)  e = loads(dumps(b, 4))  b[1].append(999)  c[1].append(999)  d[1].append(999)  e[1].append(999)  d[1].append(777)  e[1].append(777)</code></pre></li><li><p>自定义 deepcopy: <code>my_deepcopy = lambda item: loads(dumps(item, 4))</code></p></li></ul></li><li><p>迭代器, 生成器, itertools, yield, 列表 / 字典 / 集合的推导</p><pre><code> class Range:     def __init__(self, start, end):         self.start = start - 1         self.end = end     def __iter__(self):         return self     def __next__(self):         self.start += 1         if self.start &lt; self.end:             return self.start         else:             raise StopIteration()</code></pre><ul><li><p>iterator: 任何实现了 <code>__iter__</code> 和 <code>__next__</code> (python2中是 <code>next()</code>) 方法的对象都是迭代器.</p><ul><li><code>__iter__</code>返回迭代器自身</li><li><code>__next__</code> 返回容器中的下一个值</li><li>如果容器中没有更多元素, 则抛出StopIteration异常</li></ul></li><li><p>generator: 生成器其实是一种特殊的迭代器, 不需要自定义 <code>__iter__</code> 和 <code>__next__</code></p><ul><li>生成器函数 (yield)</li><li>生成器表达式</li></ul></li><li><p>练习1: 自定义一个迭代器, 实现斐波那契数列</p><pre><code>  class Fib:      def __init__(self, count):          self.prev = 0          self.curr = 1          self.count = count      def __iter__(self):          return self      def __next__(self):          if self.count &gt; 0:              # 计数              self.count -= 1              # 计算当前的值              current = self.curr              # 为下次做准备              self.prev, self.curr = self.curr, (self.curr + self.prev)              # 返回当前值              return current          else:              raise StopIteration()</code></pre></li><li><p>练习2: 自定义一个生成器函数, 实现斐波那契数列</p><pre><code>      def fib(max_value):          prev = 0          curr = 1          while curr &lt; max_value:              yield curr              prev, curr = curr, curr + prev</code></pre></li><li><p>练习3: 定义一个随机数迭代器, 随机范围为 [1, 50], 最大迭代次数 30</p><pre><code>  import random  class RandomIter:      def __init__(self, start, end, times):          self.start = start          self.end = end          self.max_times = times          self.count = 0      def __iter__(self):          return self      def __next__(self):          self.count += 1          if self.count &lt;= self.max_times:              return random.randint(self.start, self.end)          else:              raise StopIteration()</code></pre></li><li><p>迭代器、生成器有什么好处？</p><ul><li>节省内存</li><li>惰性求值</li></ul></li><li>itertools<ul><li>无限迭代<ul><li><code>count(start=0, step=1)</code></li><li><code>cycle(iterable)</code></li><li><code>repeat(object [,times])</code></li></ul></li><li>有限迭代<ul><li><code>chain(*iterables)</code></li></ul></li><li>排列组合<ul><li><code>product(*iterables, repeat=1)</code> 笛卡尔积</li><li><code>permutations(iterable[, r-length])</code> 全排列</li><li><code>combinations(iterable, r-length)</code> 组合</li></ul></li></ul></li></ul></li></ol><ol start="4"><li><p><code>method</code>, <code>classmethod</code> 和 <code>staticmethod</code></p><ul><li><code>method</code>: 通过实例调用时, 可以引用类内部的任何属性和方法</li><li><code>classmethod</code>: 无需实例化, 可以调用类属性和类方法, 无法取到普通的成员属性和方法</li><li><p><code>staticmethod</code>: 无论用类调用还是用实例调用, 都无法取到类内部的属性和方法, 完全独立的一个方法</p></li><li><p>练习: 说出下面代码的运行结果</p><pre><code>  class Test(object):      x = 123      def __init__(self):          self.y = 456      def bar1(self):          print(&#39;i am a method&#39;)      @classmethod      def bar2(cls):          print(&#39;i am a classmethod&#39;)      @staticmethod      def bar3():          print(&#39;i am a staticmethod&#39;)      def foo1(self):          print(self.x)          print(self.y)          self.bar1()          self.bar2()          self.bar3()      @classmethod      def foo2(cls):          print(cls.x)          # print(cls.y)          # cls.bar1()          Test.bar2()          Test.bar3()      @staticmethod      def foo3(obj):          print(obj.x)          print(obj.y)          obj.bar1()          obj.bar2()          obj.bar3()  t = Test()  t.foo1()  t.foo2()  t.foo3()</code></pre></li></ul></li><li><p>Python 魔术方法</p><ol><li><code>__str__</code>, <code>__repr__</code></li><li><p><code>__init__</code> 和 <code>__new__</code></p><ul><li><code>__new__</code> 返回一个对象的实例, <code>__init__</code> 无返回值</li><li><p><code>__new__</code> 是一个类方法</p><ul><li><p>单例模式</p><pre><code>  class A(object):      &#39;&#39;&#39;单例模式&#39;&#39;&#39;      obj = None      def __new__(cls, *args, **kwargs):          if cls.obj is None:              cls.obj = object.__new__(cls)          return cls.obj</code></pre></li></ul></li></ul></li><li><p>比较运算、数学运算</p><ul><li><p>运算符重载</p><ul><li><code>+</code>: <code>__add__(value)</code></li><li><code>-</code>: <code>__sub__(value)</code></li><li><code>*</code>: <code>__mul__(value)</code></li><li><code>/</code>: <code>__truediv__(value)</code> (Python 3.x), <code>__div__(value)</code> (Python 2.x)</li><li><code>//</code>: <code>__floordiv__(value)</code></li><li><code>%</code>: <code>__mod__(value)</code></li><li><code>&amp;</code>: <code>__and__(value)</code></li><li><code>|</code>: <code>__or__(value)</code></li></ul></li><li><p>练习: 实现字典的 <code>__add__</code> 方法, 作用相当于 d.update(other)</p><pre><code>  class Dict(dict):      def __add__(self, other):          if isinstance(other, dict):              new_dict = {}              new_dict.update(self)              new_dict.update(other)              return new_dict          else:              raise TypeError(&#39;not a dict&#39;)</code></pre></li><li><p>比较运算符的重载</p><ul><li><code>==</code>: <code>__eq__</code></li><li><code>!=</code>: <code>__ne__</code></li><li><code>&gt;</code>: <code>__gt__</code></li><li><code>&gt;=</code>: <code>__ge__</code></li><li><code>&lt;</code>: <code>__lt__</code></li><li><code>&lt;=</code>: <code>__le__</code></li></ul></li><li><p>练习: 完成一个类, 实现数学上无穷大的概念</p><pre><code>  class Inf:      def __lt__(self, other):          return False      def __le__(self, other):          return False      def __ge__(self, other):          return True      def __gt__(self, other):          return True      def __eq__(self, other):          return False      def __ne__(self, other):          return True</code></pre></li></ul></li><li><p>容器方法</p><ul><li><code>__len__, __iter__, __contains__</code></li><li><code>__getitem__</code> 对 <code>string, list, tuple, dict</code> 有效</li><li><code>__setitem__</code> 对 <code>list, dict</code> 有效</li><li><p><code>__missing__</code> 对 <code>dict</code> 有效</p><pre><code>  class Dict(dict):      def __missing__(self, key):          self[key] = None  # 当检查到 Key 缺失时, 可以做任何默认行为</code></pre></li></ul></li><li><p>可执行对象: <code>__call__</code></p></li><li>with:<ul><li><code>__enter__</code> 进入 <code>with</code> 代码块前的准备操作</li><li><code>__exit__</code> 退出时的善后操作</li></ul></li><li><p><code>__setattr__, __getattribute__, __getattr__, __dict__</code></p><ul><li><p>常用来做属性监听</p><pre><code>  class A:      &#39;&#39;&#39;TestClass&#39;&#39;&#39;      z = [7,8,9]      def __init__(self):          self.x = 123          self.y = &#39;abc&#39;      def __setattr__(self, name, value):          print(&#39;set %s to %s&#39; % (name, value))          object.__setattr__(self, name, value)      def __getattribute__(self, name):          print(&#39;get %s&#39; % name)          return object.__getattribute__(self, name)      def __getattr__(self, name):          print(&#39;not has %s&#39; % name)          return -1      def foo(self, x, y):          return x ** y  # 对比  a = A()  print(A.__dict__)  print(a.__dict__)</code></pre></li></ul></li><li><p>描述器: <code>__set__, __get__</code></p><ul><li><a href="http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html" target="_blank" rel="noopener">http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li><li>常见应用场景: ORM 的各种 Field 类</li></ul></li><li><p>槽: <code>__slots__</code></p><ul><li>固定类所具有的属性</li><li>实例不会分配 <code>__dict__</code></li><li>实例无法动态添加属性</li><li><p>优化内存分配</p><pre><code>  class A:      __slots__ = (&#39;x&#39;, &#39;y&#39;)</code></pre></li></ul></li></ol></li><li><p>Python 性能之困</p><ol><li>计算密集型<ul><li>CPU 长时间满负荷运行, 如图像处理、大数据运算、圆周率计算等</li><li>计算密集型: 用 C 语言补充</li><li>Profile, timeit</li></ul></li><li>I/O 密集型: 网络 IO, 文件 IO, 设备 IO 等<ul><li>多线程 / 多进程 / 协程</li><li>阻塞 -&gt; 非阻塞</li><li>同步 -&gt; 异步</li></ul></li><li>GIL 全局解释器锁<ul><li>它确保任何时候都只有一个Python线程执行。<br><img src="/image/GIL.png" alt="GIL" title="GIL"></li></ul></li><li>什么是进程、线程、协程？<ul><li>进程: 资源消耗大, 系统整体开销大, 数据通信不方便</li><li>线程: 资源消耗小, 可共享数据。上下文开销大。按时间片强制切换, 不够灵活</li><li>协程: 内存开销更小, 上下文切换开销更小。可根据事件切换, 更加有效的利用 CPU</li></ul></li><li>什么是同步、异步、阻塞、非阻塞？<ul><li>同步, 异步: 客户端调用服务器接口时</li><li>阻塞, 非阻塞: 服务端发生等待</li></ul></li><li>事件驱动 + 多路复用<ul><li>轮询: select, poll</li><li>事件驱动: epoll 有效轮询</li></ul></li><li>Greenlets / gevent | tornado / asyncio</li><li>线程安全, 锁<ul><li>获得锁之后, 一定要释放, 避免死锁</li><li>获得锁之后, 执行的语句, 只跟被锁资源有关</li><li>区分普通锁 Lock, 可重入锁 RLock</li><li>线程之间的数据交互尽量使用 Queue</li></ul></li><li>gevent<ul><li>monkey.patch</li><li>gevent.sleep 非阻塞式等待</li><li>Queue 协程间数据交互, 避免竞争</li></ul></li></ol></li><li><p>装饰器</p><ul><li><p>最简装饰器</p><pre><code>  def deco(func):      def wrap(*args, **kwargs):          return func(*args, **kwargs)      return wrap  @deco  def foo(a, b):      return a ** b</code></pre></li><li><p>原理</p><ul><li><p>对比被装饰前后的 <code>foo.__name__</code> 和 <code>foo.__doc__</code></p><pre><code>  from functools import wraps  def deco(func):      &#39;&#39;&#39;i am deco&#39;&#39;&#39;      @wraps(func)      def wrap(*args, **kwargs):          &#39;&#39;&#39;i am wrap&#39;&#39;&#39;          return func(*args, **kwargs)      return wrap</code></pre></li><li><p>简单过程</p><pre><code>  fn = deco(func)  fn(*args, **kwargs)</code></pre></li><li><p>多个装饰器调用过程</p><pre><code>  @deco1  @deco2  @deco3  def foo(x, y):      return x ** y</code></pre></li></ul></li><li><p>带参数的装饰器</p><pre><code>  def deco(n):      def wrap1(func):          def wrap2(*args, **kwargs):              return func(*args, **kwargs)          return wrap2      return wrap1</code></pre></li><li><p>装饰器类和 <code>__call__</code></p></li><li><p>使用场景</p><ul><li>参数、结果检查</li><li>缓存、计数</li><li>日志、统计</li><li>权限管理</li><li>重试</li><li>其他</li></ul></li><li><p>练习1：写一个 timer 装饰器, 计算出被装饰函数调用一次花多长时间, 并把时间打印出来</p></li><li>练习2: 写一个权限管理装饰器, 权限分为 <code>admin / member / guest</code> 三级</li><li><p>练习3: 写一个 Retry 装饰器</p><pre><code>  import time  class retry(object):      def __init__(self, max_retries=3, wait=0, exceptions=(Exception,)):          self.max_retries = max_retries          self.exceptions = exceptions          self.wait = wait      def __call__(self, f):          def wrapper(*args, **kwargs):              for i in range(self.max_retries + 1):                  try:                      result = f(*args, **kwargs)                  except self.exceptions:                      time.sleep(self.wait)                      continue                  else:                      return result          return wrapper</code></pre></li></ul></li><li><p>闭包</p><ul><li><p>说出下面函数返回值</p><pre><code>  def foo():      l = []      def bar(i):          l.append(i)          return l      return bar  f1 = foo()  f2 = foo()  # 说出下列语句执行结果  f1(1)  f1(2)  f2(3)</code></pre></li><li><p>作用域</p><ul><li>global</li><li>nonlocal</li><li>globals()</li><li>locals()</li><li><p>vars()</p><pre><code>  local namespace      |      V  global namespace      |      V  builtin namespace</code></pre></li></ul></li><li><p>更深入一点: <code>__closure__</code></p></li></ul></li><li><p>Garbage Collection (GC)</p><ul><li><p>引用计数</p><ul><li>优点: 简单、实时性高</li><li><p>缺点: 消耗资源、循环引用</p><pre><code>  l1, l2 = [], []  l1.append(l2)  l2.append(l1)</code></pre><p><img src="/image/GC.png" alt="GC"></p></li></ul></li><li><p>标记-清除, 分代收集</p></li></ul></li><li><p>继承、多继承、多态、Mixin、super</p><ul><li>继承</li><li>多态</li><li>多继承 和 Mixin</li><li><p>super</p><pre><code>  class A:      def __init__(self):          print(&#39;enter A&#39;)          self.x = 111          print(&#39;exit A&#39;)</code></pre></li></ul></li></ol><pre><code>        class B(A):            def __init__(self):                print(&#39;enter B&#39;)                A.__init__(self)                # super().__init__()                print(&#39;exit B&#39;)        class C(A):            def __init__(self):                print(&#39;enter C&#39;)                A.__init__(self)                # super().__init__()                print(&#39;exit C&#39;)        class D(B, C):            def __init__(self):                print(&#39;enter D&#39;)                B.__init__(self)                C.__init__(self)                # super().__init__()                print(&#39;exit D&#39;)        d = D()</code></pre><ol start="11"><li><p>一些技巧和误区</p><ol><li>格式化打印<ul><li>json.dumps(obj, indent=4)</li><li>json 压缩: <code>json.dumps(obj, separators=[&#39;,&#39;,&#39;:&#39;])</code></li><li>pprint</li></ul></li><li>确保能取到有效值<ul><li><code>d.get(k, default)</code></li><li><code>d.setdefault</code></li><li><code>defaultdict</code></li><li><code>a or b</code></li><li><code>x = a if foo() else b</code></li></ul></li><li>try…except… 的滥用<ul><li>不要把所有东西全都包住, 程序错误需要报出来</li><li>使用 <code>try...except</code> 要指明具体错误, <code>try</code> 结构不是用来隐藏错误的, 而是用来有方向的处理错误的</li></ul></li><li><p>利用 dict 做模式匹配</p><pre><code> def do1():     print(&#39;i am do1&#39;) def do2():     print(&#39;i am do2&#39;) def do3():     print(&#39;i am do3&#39;) def do4():     print(&#39;i am do4&#39;) mapping = {1: do1, 2: do2, 3: do3, 4: do4} mod = random.randint(1, 10) func = mapping.get(mod, do4) func()</code></pre></li><li><p><code>inf, -inf, nan</code></p></li><li>pyenv, venv, 命名空间<ul><li><a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="noopener">pyenv</a>: 管理 Python 版本</li><li>venv: 创建虚拟环境, 做环境隔离, venv 目录直接放到项目的目录里</li></ul></li><li><p>property: 把一个方法属性化</p><pre><code> class C(object):     @property     def x(self):         &quot;I am the &#39;x&#39; property.&quot;         return self._x     @x.setter     def x(self, value):         self._x = value     @x.deleter     def x(self):         del self._x</code></pre></li><li><p>else 子句: <code>if, for, while, try</code></p></li><li>collections 模块<ul><li>defaultdict</li><li>namedtuple</li><li>Counter</li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-进阶&quot;&gt;&lt;a href=&quot;#Python-进阶&quot; class=&quot;headerlink&quot; title=&quot;Python 进阶&quot;&gt;&lt;/a&gt;Python 进阶&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;PEP8 编码规范, 以及开发中的一些惯例和建议&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记2</title>
    <link href="http://yoursite.com/2018/05/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2018/05/03/学习笔记2/</id>
    <published>2018-05-03T10:16:35.000Z</published>
    <updated>2020-04-18T05:05:20.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><p>加法<br>int float str list tuple<br><strong>add</strong></p><p>减法<br>int float set<br><strong>sub</strong></p><p>乘法<br>int float str list tuple<br><strong>mul</strong></p><p>除法<br>int float<br><strong>truediv</strong></p><p>向下整除<br><strong>floordiv</strong></p><p>bin(3) -&gt; ‘0b11’<br>hex(3) -&gt; ‘0x3’<br>oct(111) -&gt; ‘0o157’</p><p>class User(Model):<br>    name = CharField()</p><p>槽</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习笔记&quot;&gt;&lt;a href=&quot;#学习笔记&quot; class=&quot;headerlink&quot; title=&quot;学习笔记&quot;&gt;&lt;/a&gt;学习笔记&lt;/h1&gt;&lt;p&gt;加法&lt;br&gt;int float str list tuple&lt;br&gt;&lt;strong&gt;add&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>web基础</title>
    <link href="http://yoursite.com/2018/05/03/django%E8%BF%9B%E9%98%B6-web%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/05/03/django进阶-web基础/</id>
    <published>2018-05-03T10:16:33.000Z</published>
    <updated>2020-04-18T05:05:20.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web基础"><a href="#web基础" class="headerlink" title="web基础"></a>web基础</h1><p>##最简单的web框架:</p><pre><code class="python"># coding: utf-8import socket(HOST, PORT) = &#39;0.0.0.0&#39;, 8888RESPONSE = b&#39;&#39;&#39;HTTP/1.1 200 OK&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;&gt;&lt;/body&gt;&lt;/html&gt;&#39;&#39;&#39;server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)   # 建立 SOCK 连接server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # 设置参数server_socket.bind((HOST, PORT))                                    # 绑定 IP:端口server_socket.listen(100)                                           # 开始监听print(&#39;Serving HTTP on port %s ...&#39; % PORT)while True:    client_socket, client_address = server_socket.accept()  # 接收客户端发起的连接请求    request = client_socket.recv(1024)                      # 接收客户端数据, 一次最多 1024 字节    # WSGI    print(&#39;Request &gt;&gt;&gt;&#39;)    print(request.decode(&#39;utf-8&#39;))    http_response = RESPONSE    # WSGI    client_socket.sendall(http_response)    client_socket.close()</code></pre><p>三次握手的过程</p><p><code>client</code>—————————————<code>server</code></p><p>1                 syn   -&gt;</p><p>2 &lt;-         ack + syn   ack是对syn的应答</p><p>3                    -&gt;ack</p><hr><p><code>python:模块,包,装饰器,迭代器,生成器,with,__new__,__dict__,魔术方法</code></p><p><code>框架:django,falsk,scrapy,gevent,tornado</code></p><p><code>Nginx,Redis,MySQL</code></p><hr><h3 id="web基础总结"><a href="#web基础总结" class="headerlink" title="web基础总结"></a>web基础总结</h3><ol><li><p><strong>HyperText Transfer Protocol</strong></p><p> i. HTTP 1.0 (1996) / 1.1 (1997) / 2.0 (2015)</p><p>ii. 构建在 TCP 应用层之上的协议 </p><p>iii. 应用领域</p><p>iv. 认识 URL (统一资源定位符) </p><p><a href="http://example.com:80/foo/bar/readme?x=0&amp;y=abc#part1" target="_blank" rel="noopener">http://example.com:80/foo/bar/readme?x=0&amp;y=abc#part1</a> </p><p>组成 </p><p>scheme: http</p><p> hostname: example.com </p><p>port: 80 </p><p>path: /foo/bar/readme </p><p>query: ?x=0&amp;y=abc </p><p>fragment: #part1</p></li><li><p><strong>Python 系常见 Web 框架</strong></p><p> <strong>Django</strong> </p><p>全能型框架, 大而全, 插件丰富, 文档丰富, 社区活跃, 适合快速开发, 内部耦合比较紧 </p><p><strong>Flask</strong> </p><p>微型框架, 适合新手学习, 极其灵活, 便于二次开发和扩展, 生态环境好, 插件丰富 <strong>Tornado</strong> </p><p>异步处理, 事件驱动 (epoll), 性能优异 </p><p><strong>web.py</strong> </p><p>代码优秀, 适合学习源码 </p><p><strong>bottle</strong></p><p> 单文件框架 </p><p><strong>其他</strong> </p><p>Falcon web2py Quixote Sanic</p></li><li><p><strong>点击一个链接后, 都发生了什么</strong> </p><p>i. <strong>DNS解析</strong> </p><p>​    example.com -&gt; 93.184.216.34 </p><p>​    dig example.com </p><p>​    nslookup example.com </p><p>​    /etc/hosts </p><p>ii. <strong>建立TCP</strong> </p><p>​    a. SYN </p><p>​    b. ACK + SYN </p><p>​    c. ACK </p><p>iii. <strong>浏览器生成 Request 报文</strong></p><p>iv. <strong>Client 发送 Request 报文</strong> </p><p>v. <strong>Server 接收报文</strong> </p><p>vi. <strong>通过 WSGI 解析报文, 获得 Request 对象</strong> </p><p>vii. <strong>Django</strong>、<strong>Flask 等应用程序进行逻辑处理</strong> </p><p>​    a. 生成 Request 对象 </p><p>​    b. process_request (Middleware) </p><p>​    c. URL match </p><p>​    d. process_views (Middleware) </p><p>​    e. Views –&gt; process_exception </p><p>​    f. Redner Template </p><p>​    g. Response </p><p>​    h. process_response (Middleware) </p><p><strong>viii. 从 Response 对象生成报文 </strong></p><p><strong>ix. Server 返回报文给 Client </strong></p><p><strong>x. 关闭连接 </strong></p><p><strong>xi. 解析、渲染 HTML 页面</strong></p></li><li><p><strong>最简单的 Server </strong></p><p><strong>HTTP Server</strong></p><pre><code> 创建、关闭连接 发送、接收数据</code></pre><p> <strong>WSGI:</strong> </p><p>​    沟通 HTTPServer 和 Web 应用程序 之间的接口 </p><p><strong>Web Application</strong> </p><p>​    网络程序的功能和逻辑 解析用户请求, 生成 HTML 页面</p></li><li><p><strong>常见 Header 字段</strong></p><p> Accept text/plain </p><p>Accept-Charset utf-8 </p><p>Accept-Encoding gzip (Content-Encoding) </p><p>Accept-Language zh-CN en-US </p><p>Cache-Control true,max-age </p><p>Connection keep-alive </p><p>Content-Length 请求体/响应体的长度 </p><p>Content-Type 用于指定响应的HTTP内容类型. 如果未指定 默认为 text/html User-Agent 浏览器标识</p></li><li><p><strong>HTTP 状态码</strong> </p><p>200 <strong>OK</strong> 成功 </p><p>301 <strong>Moved Permanently</strong> 重定向 (永久迁移) </p><p>302 <strong>Moved Temporarily</strong> 重定向 (临时迁移) </p><p>303 <strong>See Other</strong> 重定向 (非 GET 请求的重定向) </p><p>400 <strong>Bad Request</strong> 客户端请求错误 </p><p>403 <strong>Forbidden</strong> 拒绝访问 </p><p>404 <strong>Not Found</strong> 找不到页面 </p><p>500 <strong>Internal Server Error</strong> 服务器内部错误 </p><p>502 <strong>Bad Gateway</strong> 网关错误 </p><p>503 <strong>Service Unavailable</strong> 服务器维护或者过载 </p><p>504 <strong>Gateway Timeout</strong> 请求超时</p></li><li><p><strong>GET 和 POST</strong> </p><p><strong>表象</strong> </p><p>​    GET 在浏览器可以回退, 而 POST 则会再次提交请求 </p><p>​    GET 的 URL 可以被 Bookmark, 而 POST 不可以. </p><p>​    GET 请求会被浏览器主动缓存, 而 POST 不会, 除非手动设置. </p><p>​    GET 请求参数会被完整保留在浏览器历史记录里, 而 POST 中的参数不会被保留. </p><p>​    GET 请求的数据只能进行 URL 编码, 而 POST 支持多种编码方式. </p><p>​    GET 请求在 URL 中传送的参数是有长度限制的 (URL 的最大长度是 2048 个字符), 对参数的数据类型, GET 只接受 ASCII 字符, 而 POST 没有限制. </p><p>​    GET 比 POST 更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息. </p><p>​    GET 参数通过 URL 传递, POST 放在 Request body 中. </p><p><strong>深层</strong> </p><p>​    GET 产生一个TCP数据包；POST产生两个TCP数据包. </p><p>​    GET: 浏览器会把 http 的 header和data一并发送出去, 服务器响应200（返回数据） </p><p>​    POST: 浏览器先发送 header, 服务器响应 100 continue, 浏览器再发送data, 服务器</p></li><li><p><strong>cookie 和 session</strong> </p><p><strong>无状态协议的无奈之举</strong></p><p>​    通信如同一次无法看到脸的握手, 如何识别用户 </p><p><strong>异同</strong> </p><p>​    a. session 在服务器端, cookie 在客户端（浏览器） </p><p>​    b. session 默认被存在在服务器的一个文件里（不是内存） </p><p>​    c. session 的运行依赖 session id, 而 session id 是存在 cookie 中的, 也就是说, 如果浏 session 也会失效（但是可以通过其它方式实现, 比如在 url 中传递 session_id） </p><p>​    d. session 可以放在 文件、数据库、或内存中都可以. </p><p>​    e. 用户验证这种场合一般会用 session </p><p><strong>产生过程</strong> </p><p>​    a. 客户端请求 </p><p>​    b. 服务器产生 session_id, 并传回浏览器 </p><p>​    c. 浏览器将 session_id 写入 cookie </p><p>​    d. 后续请求会写入 Header 使用</p></li><li><p><strong>RESTful</strong> </p><p>一种网络软件架构风格, 而非标准 </p><p>用 URL 定位一个网络资源 </p><p>用 HTTP 描述对资源的操作 </p><p><strong>四个动词</strong> </p><p>​    GET: 用来获取资源 </p><p>​    POST: 用来新建资源 </p><p>​    PUT: 用来更新资源 </p><p>​    DELETE: 用来删除资源 </p><p><strong>误区</strong> </p><p>​    URL 中使用动词 </p><p>​    URL 中出现版本号, 版本号放在 Header</p></li><li><p><strong>HTTPS</strong> </p><p><strong>优点</strong> </p><p>​    防窃听: 建立一个信息安全通道，来保证数据传输的安全 </p><p>​    防篡改: 防止内容被第三方修改 </p><p>​    放冒充: 确认网站的真实性 </p><p><strong>缺点</strong> </p><p>​    加密、解密消耗 CPU </p><p>​    握手过程繁琐 </p><p><strong>SSL / TLS (安全套接字层)</strong> </p><p><strong>加密算法</strong> </p><p>​    <strong>对称加密: TEA, AES, 3DES</strong> </p><p>​        text: abcdefg </p><p>​            |   ^</p><p>​            v   |</p><p>​        key: 1234 </p><p>​            |  ^ </p><p>​            v  | </p><p>​        new: hasjdkfhasdf </p><p>​    <strong>非对称加密: RSA, ED25519</strong> </p><p>​        text: abcdefghijklmn </p><p>​                |      ^   </p><p>​                v      |</p><p>​        pub_key: 123 | </p><p>​        pri_key:  |     1234567890123456789546789 </p><p>​                |       ^ </p><p>​                v     | </p><p>​        new: ajsgdpfqibwfmbsdlkfjbq;ejkwbf;qkbfd </p><p><strong>Let’s Encrypt: <a href="https://letsencrypt.org/" target="_blank" rel="noopener">https://letsencrypt.org/</a></strong> </p><p><strong>传输过程</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web基础&quot;&gt;&lt;a href=&quot;#web基础&quot; class=&quot;headerlink&quot; title=&quot;web基础&quot;&gt;&lt;/a&gt;web基础&lt;/h1&gt;&lt;p&gt;##最简单的web框架:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# coding: utf-8
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记</title>
    <link href="http://yoursite.com/2018/05/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/03/学习笔记/</id>
    <published>2018-05-03T10:16:33.000Z</published>
    <updated>2020-04-18T05:05:20.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h2 id="开发工具栈"><a href="#开发工具栈" class="headerlink" title="开发工具栈"></a>开发工具栈</h2><pre><code>1. sublime2. zsh + oh-my-zsh3. tmux4. vim5. 常用配置: &lt;https://github.com/seamile/Weeds/tree/master/rc.d&gt;</code></pre><h2 id="限制访问频率"><a href="#限制访问频率" class="headerlink" title="限制访问频率"></a>限制访问频率</h2><p>频率最大为每秒 2 次</p><pre><code>    requests     time.time()    --------     -----------    request 1 -&gt; 1000.000    request 2 -&gt; 1000.230    request 3 -&gt; 1001.930    request 4 -&gt; 1002.900    request 5 -&gt; (1003.130 - 1001.930) &lt; 1    request 6 -&gt; 1003.140    request 7 -&gt; 1003.140    request 8 -&gt; 1003.140    request 9 -&gt; 1003.140    request 10 -&gt; 1003.140    request 11 -&gt; 1003.140</code></pre><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><ol><li>多对多关系，一般建立一个关系表</li></ol><p>Article 表<br>    id</p><p>Tag 表<br>    id<br>    name</p><p>关系表<br>    article_id<br>    tag_id</p><h2 id="创建或更新过程"><a href="#创建或更新过程" class="headerlink" title="创建或更新过程"></a>创建或更新过程</h2><p>文章 Article(33)</p><pre><code>   1        2         3</code></pre><p>原来的 ‘python’, ‘django’, ‘linux’<br>传入   ‘python’, ‘django’,          ‘mongodb’<br>                                    4</p><p>ArticleTags</p><p>33 1<br>33 2</p><p>33 4</p><h2 id="权限管理功能"><a href="#权限管理功能" class="headerlink" title="权限管理功能"></a>权限管理功能</h2><p>做设计时要有 “前瞻性”</p><p>给用户添加权限</p><p>user<br>    id</p><p>permission<br>    id</p><p>group<br>    id<br>    pid</p><p>参考链接<br><a href="https://www.zhihu.com/question/20313385" target="_blank" rel="noopener">https://www.zhihu.com/question/20313385</a><br><a href="http://blog.csdn.net/painsonline/article/details/7183613/" target="_blank" rel="noopener">http://blog.csdn.net/painsonline/article/details/7183613/</a></p><h2 id="Gunicorn"><a href="#Gunicorn" class="headerlink" title="Gunicorn"></a>Gunicorn</h2><p>多进程 + 协程 (greenlet)</p><p>Gunicorn<br>uWSGI</p><p>压力测试<br>ab (Apache Bench)<br>webbench<br>autobench</p><p>RPS 每秒请求量<br>QPS 每秒查询量</p><p>10 Concurrency  1000 Request<br>gunicorn 614 r/s<br>django   510 r/s</p><p>Unix 一切皆文件</p><p>文件描述符</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>正向代理</p><p>内网环境 -&gt; 代理 -&gt; 公网机器</p><p>反向代理</p><p>用户 -&gt; Nginx -&gt; 服务器内网环境</p><h2 id="DB-集群"><a href="#DB-集群" class="headerlink" title="DB 集群"></a>DB 集群</h2><p>读写分离</p><h2 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h2><pre><code> 写     读 |      ^ V      |主机 -&gt; 从机</code></pre><p>一主两从甚至一主多从</p><h2 id="双主互备"><a href="#双主互备" class="headerlink" title="双主互备"></a>双主互备</h2><pre><code>主机 &lt;-&gt; 主机     从</code></pre><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>北京    源站<br>上海    镜像站<br>深圳    镜像站<br>乌鲁木齐 镜像站<br> .<br> .<br> .<br>美国    镜像站</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习笔记&quot;&gt;&lt;a href=&quot;#学习笔记&quot; class=&quot;headerlink&quot; title=&quot;学习笔记&quot;&gt;&lt;/a&gt;学习笔记&lt;/h1&gt;&lt;h2 id=&quot;开发工具栈&quot;&gt;&lt;a href=&quot;#开发工具栈&quot; class=&quot;headerlink&quot; title=&quot;开发工具栈&quot;&gt;
      
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python常用ms</title>
    <link href="http://yoursite.com/2018/04/24/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/24/面试总结/</id>
    <published>2018-04-24T08:10:15.000Z</published>
    <updated>2020-04-18T05:05:20.224Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h2 id="技术面试准备"><a href="#技术面试准备" class="headerlink" title="技术面试准备"></a>技术面试准备</h2><p><a href="https://github.com/taizilongxu/interview_python" target="_blank" rel="noopener">https://github.com/taizilongxu/interview_python</a></p><h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><ul><li><p>面向对象</p><p>三大特性:继承,多态,封装</p><p>面向过程vs面向对象: 面向过程的优点是程序复杂度低,只要顺着执行步骤堆叠代码即可,缺点是一套流程解决一个问题,牵一发而动全身.</p><p>著名的应用:Linux内核,git,Apache server等</p><p>面向对象的核心思想万物皆对象,解决了程序的扩展性,对某个对象修改会立刻反应到体系中.缺点是可控性差,解决问题一开始就是由对象之间的交互来解决.</p><ul><li><p>类,对象,实例,实例化</p><p>类:具有相同特征的一类事物     对象/实例:具体的某个事物</p><p>实例化,类—&gt;对象的过程</p><pre><code>&gt;&gt;&gt; dict #类型dict就是类dict&lt;class &#39;dict&#39;&gt;&gt;&gt;&gt; d=dict(name=&#39;eva&#39;) #实例化&gt;&gt;&gt; d.pop(&#39;name&#39;) #向d发一条消息，执行d的方法pop&#39;eva&#39;--------------------------egg = Person(&#39;egon&#39;)  #类名()就等于在执行Person.__init__()#执行完__init__()就会返回一个对象。这个对象类似一个字典，存着属于这个人本身的一些属性和方法。#你可以偷偷的理解：egg = {&#39;name&#39;:&#39;egon&#39;,&#39;walk&#39;:walk}</code></pre></li></ul></li><li><p>设计模式 - 单例 - 装饰器 - MVC</p><ul><li><p>单例模式 - 它的核心结构中只包含一个被称为单例类的特殊类,通过单例模式可以 保证系统中一个类只有一个实例且该实例易于外接访问,从而方便对实例的个数的控制并节约系统资源.如果希望在系统中某个类的对象只能存在一个,单例模式是最好的解决方案.__new__()在__init__()之前被调用,用于生产实例对象,利用这个方法和类属性可以实现单例.</p><p>使用__new__()</p><pre><code class="python">class Func(object):    def __new__(cls,*args,**kw):        if not hasattr(cls,&#39;_instance&#39;):            a = super(Func,cls)            cls._instance = a.__new__(cls,*args,**kw)         return cls._instanceclass Myclass(Func):    b = 1</code></pre><p>import 方法</p><p>装饰器方法</p><pre><code class="python">def func(cls,*args,**kw):    instances = {}    def get_instance():        if cls not in instances:            instances[cls] = cls(*args,**kw)        return instances[cls]    return get_instance@funcclass MyClass:    ...</code></pre></li></ul></li><li><p>网络编程-HTTP,TCP,UDP,ajax</p><ul><li><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术</p></li><li><p>http:是用于www浏览的一个协议。但是基于tcp的<br>tcp：是机器之间建立连接用的到的一个协议。</p><p>|            | TCP                                    | UDP                                  |<br>| ———- | ————————————– | ———————————— |<br>| 是否连接   | 面向连接                               | 面向非连接                           |<br>| 传输可靠性 | 可靠                                   | 不可靠                               |<br>| 应用场合   | 传输大量的数据，对可靠性要求较高的场合 | 传送少量数据、对可靠性要求不高的场景 |<br>| 速度       | 慢                                     | 快                                   |</p><p>1 三次握手<br>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。<br>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。<br>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。<br>2 四次挥手<br>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</p><p>客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.<br>服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.<br>服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.<br>客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.</p></li></ul></li><li><p>多线程,多进程,协程</p><ul><li><p>计算机硬件角度:</p><p>计算机核心是cpu,承担了所有的计算任务,一个cpu,在一个时间切片里只能运行一个程序.</p></li><li><p>从操作系统的角度:</p><p>进程和线程,都是一种cpu的执行单元,进程:表示一个程序的上下文执行活动(打开,执行,保存)</p><p>线程:进程执行程序时的最小调度单位,一个程序至少有一个进程,一个进程至少有一个线程.</p></li><li><p>并行:</p><p>多个cpu核心,不同的程序分给不同的cpu运行,可以让多个程序同时执行.</p></li><li><p>并发:单个cpu核心,在一个时间切片里一次只能运行一个程序,如果需要运行多个程序,则串行执行.</p></li><li><p>多进程  - 多线程</p><p>同时执行多个任务</p><p>进程:每个进程都有自己独立的内存空间,不同进程之间的内存空间不共享,进城之间的通信由操作系统偿还地,导致通讯效率低,切换开销大.</p><p>线程:一个进程可以有多个线程，所有线程共享进程的内存空间，通讯效率高，切换开销小。共享意味着竞争，导致数据不安全，为了保护内存空间的数据安全，引入”互斥锁”。</p><p>一个线程在访问内存空间时其他线程不允许访问,必须等待之前的线程访问结束,才能使用这个内存空间.</p><hr><p>Python的多线程：</p><p>GIL 全局解释器锁：线程的执行权限，在Python的进程里只有一个GIL。</p><p>一个线程需要执行任务，必须获取GIL。</p><p>好处：直接杜绝了多个线程访问内存空间的安全问题。<br>坏处：Python的多线程不是真正多线程，不能充分利用多核CPU的资源。</p><p>但是，在I/O阻塞的时候，解释器会释放GIL。</p><p>多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，大量的并行计算）的时候，用多进程。 multiprocessing<br>缺陷：多个进程之间通信成本高，切换开销大。</p><p>多线程：密集I/O任务（网络I/O，磁盘I/O，数据库I/O）使用多线程合适。<br>threading.Thread、multiprocessing.dummy<br>缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。</p><p>协程：又称微线程，在单线程上执行多个任务，用函数切换，开销极小。不通过操作系统调度，没有进程、线程的切换开销。genvent，monkey.patchall</p><p>多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。</p><p>缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高.</p><hr><p>多进程multiprocessing模块</p><p>多线程threading</p><p>协程 from gevent import monkey</p><hr><p>处理高并发:</p><p>twisted—&gt;tornad0—&gt;gevent</p></li></ul></li><li><p>数据库</p><ul><li><p>事务</p><p>原子性,一致性,隔离性,持久性</p></li><li><p>数据库索引</p><p>建立索引的原则:</p><p>1,最左前缀匹配原则,MySQL会一直向右匹配到范围查询就停止匹配.    </p><p>比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2,=和in可以乱序比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p><p>3,尽量选择区分度高的列作为索引</p><p>4,索引列不能参与运算</p><p>5,尽量的扩展索引,不要新建索引</p><hr><p><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/mysql-index.html</a></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p></li><li><p>redis</p><p>k-v数据库,丰富的数据结构string,map,list,sets,sorted sets</p><blockquote><p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作</p></blockquote><ul><li>速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万</li><li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)</li><li>自动操作：对不同数据类型的操作都是自动的，很安全</li><li>快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。</li><li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li></ul></li><li><p>redis的缺点</p><ul><li>是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul></li><li><p>乐观锁和悲观锁</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p></li><li><p>6 MyISAM和InnoDB<br>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a> MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p><p>​</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;技术面试准备&quot;&gt;&lt;a href=&quot;#技术面试准备&quot; class=&quot;headerlink&quot; title=&quot;技术面试准备&quot;&gt;&lt;/a&gt;技术面试准备&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/taizilongxu/inte
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>git 解决push报错</title>
    <link href="http://yoursite.com/2018/04/22/git-%E8%A7%A3%E5%86%B3push%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2018/04/22/git-解决push报错/</id>
    <published>2018-04-22T10:04:30.000Z</published>
    <updated>2020-04-18T05:05:20.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-解决push报错问题"><a href="#git-解决push报错问题" class="headerlink" title="git -解决push报错问题"></a>git -解决push报错问题</h1><h3 id="问题出现场景"><a href="#问题出现场景" class="headerlink" title="问题出现场景"></a>问题出现场景</h3><p>github新建仓库,想把本地仓库推送到github</p><hr><p>操作步骤</p><ol><li><p>进入本地仓库,假设项目为test</p><p><code>cd test</code></p><p><code>git init</code></p></li><li><p>查看状态</p><p><code>git status</code></p></li><li><p>把更改的文件添加到本地git仓库</p><p><code>git add .</code></p></li><li><p>设置用户名邮箱</p><p><code>git config --global user.name &#39;jimi&#39;</code></p><p><code>git config --global user.email &#39;jimi@163.com</code></p></li><li><p>提交</p><p><code>git commit -m &quot;first commit&quot;</code></p></li><li><p>把本地test项目和githhub的test项目进行关联</p><p><code>git remote add origin xxxxx@xxxx</code></p></li><li><p>向远程仓库提交代码(配置好ssh或者密码)</p><p><code>git push origin master</code></p><p>可能会出现问题:</p><pre><code class="shell">$ git push origin master  To github.com:JasonLi-cn/test.git   ! [rejected]        master -&gt; master (fetch first)  error: failed to push some refs to &#39;git@github.com:JasonLi-cn/test.git&#39;  hint: Updates were rejected because the remote contains work that you do  hint: not have locally. This is usually caused by another repository pushing  hint: to the same ref. You may want to first integrate the remote changes  hint: (e.g., &#39;git pull ...&#39;) before pushing again.  hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. </code></pre><p>说明远程仓库有本地仓库没有的文件,需要先pull</p><p><code>git pull origin master</code></p><p>这时可能会遇到问题:</p><pre><code>$ git pull origin master  From github.com:JasonLi-cn/test   * branch            master     -&gt; FETCH_HEAD  fatal: refusing to merge unrelated histories  </code></pre><p>解决办法:</p><p><code>git pull origin master --allow-unrelated-histories</code></p><p>这时就可以push了.</p><p>如果远程仓库有和本地仓库一样的文件还不能直接push,git status发现:</p><pre><code>On branch masterYou have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)    both added:      LICENSE</code></pre><p>只需要执行如下操作然后重新提交就行了</p><pre><code class="Shell">git rm LICENSEgit add .git commit -m &quot;merge&quot;git push origin master</code></pre></li></ol><hr><p>最好推荐几篇写的非常不错的git入门文章:</p><p><a href="http://stormzhang.com/github/2016/05/25/learn-github-from-zero1/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「初识 GitHub」</a></p><p><a href="http://stormzhang.com/github/2016/05/26/learn-github-from-zero2/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「加入 GitHub」</a></p><p><a href="http://stormzhang.com/github/2016/05/30/learn-github-from-zero3/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「Git 速成」</a></p><p><a href="http://stormzhang.com/github/2016/06/04/learn-github-from-zero4/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「向GitHub 提交代码」</a></p><p><a href="http://stormzhang.com/github/2016/06/16/learn-github-from-zero5/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「Git 进阶」</a></p><p><a href="http://stormzhang.com/github/2016/07/09/learn-from-github-from-zero6/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「团队合作利器 BRANCH」</a></p><p><a href="http://stormzhang.com/github/2016/07/28/learn-github-from-zero7/" target="_blank" rel="noopener">从0开始学习 GitHub 系列之「如何发现优秀的开源项目？」</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-解决push报错问题&quot;&gt;&lt;a href=&quot;#git-解决push报错问题&quot; class=&quot;headerlink&quot; title=&quot;git -解决push报错问题&quot;&gt;&lt;/a&gt;git -解决push报错问题&lt;/h1&gt;&lt;h3 id=&quot;问题出现场景&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Sublime text 常用插件</title>
    <link href="http://yoursite.com/2018/04/21/Sublime-text-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/21/Sublime-text-常用插件/</id>
    <published>2018-04-20T16:15:21.000Z</published>
    <updated>2020-04-18T05:05:20.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sublime-text3常用插件"><a href="#Sublime-text3常用插件" class="headerlink" title="Sublime text3常用插件"></a>Sublime text3常用插件</h1><p>集成插件：</p><p>(1)Alignment: 代码对齐插件，即”=”号对齐，变量定义太多，长短不一，可一键对齐，默认快捷键Ctrl+Alt+A可能和QQ截屏功能冲突，可设置其他快捷键如：Ctrl+Shift+Alt+A<br>(2)AutoFileName: 快捷输入文件名插件，自动完成文件名的输入，如图片选取，输入”/”即可看到相对于本项目文件夹的其他文件。<br>(3)BracketHighlighter: 代码匹配插件，可匹配[], (), {}, “”, ”, ，高亮标记，便于查看起始和结束标记，点击对应代码即可。<br>(4)ClipboardHistory: 剪切板历史记录插件，方便使用复制/剪切的内容，Ctrl+alt+v：显示历史记录，Ctrl+alt+d：清空历史记录，Ctrl+shift+v：粘贴上一条记录（最旧），Ctrl+shift+alt+v：粘贴下一条记录（最新）<br>(5)CodeFormatter: 代码格式化插件，支持PHP、JavaScript/JSON、HTML、CSS/SCSS、Python、Visual Basic、Coldfusion/Railo/Lucee等等。<br>(6)ConvertToUTF8: 编辑并保存目前编码不被 Sublime Text 支持的文件，特别是中日韩用户使用的GB2312，GBK，BIG5，EUC-KR，EUC-JP ，ANSI等。<br>(7)DocBlockr: 代码注释插件，标准的注释，包括函数名、参数、返回值等，并以多行显示，省去手动编写。<br>(8)Emmet: HTML/CSS代码快速编写插件，对于前端来说，可是必备插件。<br>(9)FileDiffs: 强大的比较代码不同工具，比较当前文件与选中的代码、剪切板中代码、另一文件、未保存文件之间的差别，右键标签页，出现FileDiffs Menu或者Diff with Tab…选择对应文件比较即可。<br>(10)Git: Git管理插件，基本上实现了Git的所有功能。<br>(11)IMESupport: 实现中文输入法鼠标跟随插件。<br>(12)KeymapManager: 快捷键管理插件，通过Ctrl+alt+k或者通过顶部菜单“查看 -&gt; 快捷键管理”打开面板。<br>(13)PackageControl: 插件管理插件，提供添加、删除、禁用、查找插件等功能。<br>(14)SideBarEnhancements: 侧边栏右键增强插件，可以自定义打开方式快捷键，非常实用。<br>(15)SublimeCodeIntel: 代码自动提示插件，支持绝大多数前端开发语言。<br>(16)SublimeLinter: 代码语法检测插件，支持C/C++、CSS、HTML、Java、JavaScript、Lua、Perl、PHP、Python、Ruby、XML等等。<br>(17)SyncedSidebarBg: 侧边栏与主题颜色同步更新插件，自动同步侧边栏底色为编辑窗口底色。<br>(18)Theme-Nil: 完美的编码主题，用过的都说很好。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Q：如何安装插件？<br>A：按快捷键Ctrl+Shift+P，输入 install 并回车，选择相应插件安装即可。或者依次点击“首选项 – 插件控制 – Install Package”进行插件安装。<br>Q：如何修改侧边栏背景颜色？<br>A：修改主题的配置文件即可。例如：使用流风清音汉化版，其默认主题为“Nil-Theme”，那么配置文件的相应路径是“Data\Packages\Nil-Theme\Nil.sublime-theme”。</p><pre><code class="json">/** Sidebar tree (bg) **/{“class”: “sidebar_tree”,“dark_content”: true,“row_padding”: [12, 4],“indent”: 13,“indent_offset”: 15,“indent_top_level”: false,“layer0.tint”: [32,32,32], /* darker gray */ /* 输入喜欢的颜色的对应RGB值即可 */“layer0.opacity”: 1.0,“dark_content”: true},</code></pre><p>Q：为什么在Win8系统出现中文乱码？<br>A：这是Win8权限问题，一种方法是卸载后重装到系统之外的分区，另一种方法则是以管理员身份运行。<br>Q：为什么输入光标变得很粗？<br>A：依次点击“首选项” – “设置 – 用户”打开文件，按原有格式添加以下配置即可。提示：记得给原来的最后一行末尾添加一个半角逗号。<br>“caret_style”: “phase”,<br>“caret_extra_top”: 0,<br>“caret_extra_bottom”: 0,<br>“caret_extra_width”: 1,<br>Q：为什么侧边栏出现双文件夹图标？<br>A：在主题模板规则中添加如下配置即可。</p><pre><code class="json">{“class”: “icon_folder”,“content_margin”: [0,0]},{“class”: “icon_file_type”,“content_margin”: [0,0]},{“class”: “icon_folder_loading”,“content_margin”: [0,0]}</code></pre><p>Q：为什么侧边栏和标签栏上中文的文件名显示“口口”，而英文的文件名显示正常？<br>A：这里以Win7来说明，桌面 – 鼠标右键 – 个性化 – 显示 – 设置自定义文本大小(DPI) – 选择“较小 – 100%(默认)”即可。或者点击“首选项” – “设置 – 用户”打开文件，在末尾加上一行代码覆盖系统的DPI。<br>“dpi_scale”: 1.0,</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sublime-text3常用插件&quot;&gt;&lt;a href=&quot;#Sublime-text3常用插件&quot; class=&quot;headerlink&quot; title=&quot;Sublime text3常用插件&quot;&gt;&lt;/a&gt;Sublime text3常用插件&lt;/h1&gt;&lt;p&gt;集成插件：&lt;/p&gt;

      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>pycharm操作技巧</title>
    <link href="http://yoursite.com/2018/04/20/pycharm%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/04/20/pycharm操作技巧/</id>
    <published>2018-04-19T16:42:43.000Z</published>
    <updated>2020-04-18T05:05:20.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pycharm使用技巧"><a href="#pycharm使用技巧" class="headerlink" title="pycharm使用技巧"></a>pycharm使用技巧</h1><ul><li><p>常用快捷键</p><p><img src="/image/pycharm for mac.jpg" alt="pycharm for mac"></p><p><img src="/image/pycharm for win.jpg" alt="pycharm for win"></p></li><li><p>查看使用库源码</p><p><code>Command+B</code>  或 <code>command+click</code></p></li><li><p>让代码PEP8</p><p><code>Command+OPtion+L</code></p></li><li><p>查找文件,类,方法</p><p><code>Command+Shift+O</code></p></li><li><p>快速选择代码</p><p>选择某个函数时,把光标放在最前面然后点击</p><p><code>Command+Option+Shift+[</code></p></li><li><p>快速注释</p><p><code>Command+/</code></p></li><li><p>快速插入常用代码如if_name_==’__main__‘:</p><p><code>command+J</code></p></li><li><p>运行/调试代码</p><p><code>command+R</code></p></li><li><p>缩进代码块</p><p><code>shift+上下键</code> 然后用Tab键</p></li><li><p>展开/收缩代码</p><p><code>command+shift+加减号</code></p></li><li><p>设置代码模板</p><pre><code class="python">#-*- coding:utf-8 _*-  &quot;&quot;&quot; @author:${USER} @file: ${NAME}.py @time: ${YEAR}/${MONTH}/{DAY} &quot;&quot;&quot;  </code></pre></li><li><p>函数调用层级可视化</p><p><code>导航(Navigate)调用层次结构(call H*)</code></p></li><li><p>显示文档和函数参数</p><p><code>command+P</code></p></li><li><p>超实用搜索Search Everywhere</p><p><code>double shift</code></p></li><li><p>快速创建测试</p><p><code>导航  test</code></p></li><li><p>可以利用ssh远程部署</p><p>tools -&gt;第一行里面的configserver</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pycharm使用技巧&quot;&gt;&lt;a href=&quot;#pycharm使用技巧&quot; class=&quot;headerlink&quot; title=&quot;pycharm使用技巧&quot;&gt;&lt;/a&gt;pycharm使用技巧&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常用快捷键&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>U盘量产修复金士顿PS2251-07(PS2307)</title>
    <link href="http://yoursite.com/2018/04/16/U%E7%9B%98%E9%87%8F%E4%BA%A7%E4%BF%AE%E5%A4%8D%E9%87%91%E5%A3%AB%E9%A1%BFPS2251-07-PS2307/"/>
    <id>http://yoursite.com/2018/04/16/U盘量产修复金士顿PS2251-07-PS2307/</id>
    <published>2018-04-16T13:49:32.000Z</published>
    <updated>2020-04-18T05:05:20.222Z</updated>
    
    <content type="html"><![CDATA[<pre><code></code></pre><h1 id="群联MPALL-Rel-7F-V5-03-0A-DL07量产PS2251-07-PS2307-步骤"><a href="#群联MPALL-Rel-7F-V5-03-0A-DL07量产PS2251-07-PS2307-步骤" class="headerlink" title="群联MPALL(Rel)-7F-V5.03.0A-DL07量产PS2251-07(PS2307)步骤"></a>群联MPALL(Rel)-7F-V5.03.0A-DL07量产PS2251-07(PS2307)步骤</h1><p>教程截取自<a href="http://www.liangchanba.com/article-2442-1.html" target="_blank" rel="noopener">量产吧</a></p><p><img src="/image/huaban.png" alt></p><h3 id="注意：根据此教程量产的U盘有写保护，第十步时Filesystem不要用default，选择fat32，最后完成变绿时马上拔下U盘。可以解决有写保护的问题。"><a href="#注意：根据此教程量产的U盘有写保护，第十步时Filesystem不要用default，选择fat32，最后完成变绿时马上拔下U盘。可以解决有写保护的问题。" class="headerlink" title="注意：根据此教程量产的U盘有写保护，第十步时Filesystem不要用default，选择fat32，最后完成变绿时马上拔下U盘。可以解决有写保护的问题。"></a>注意：根据此教程量产的U盘有写保护，第十步时Filesystem不要用default，选择fat32，最后完成变绿时马上拔下U盘。可以解决有写保护的问题。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;群联MPALL-Rel-7F-V5-03-0A-DL07量产PS2251-07-PS2307-步骤&quot;&gt;&lt;a href=&quot;#群联MPALL-Rel-7F-V5-03-0A-DL07量产PS2251-07-PS2307
      
    
    </summary>
    
      <category term="U盘修复" scheme="http://yoursite.com/categories/U%E7%9B%98%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
</feed>
